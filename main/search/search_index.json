{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>iden</code> is a simple Python library to manage a dataset of shards when training a machine learning model. <code>iden</code> uses a lazy loading approach to load the shard's data, so it is easy to manage shards without loading their data. <code>iden</code> supports different formats to store shards on disk.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Lazy Loading: Shards are loaded only when needed, enabling efficient memory management</li> <li>Multiple Formats: Support for JSON, YAML, Pickle, PyTorch, safetensors, and more</li> <li>Flexible Dataset Management: Organize data into splits (train/val/test) with associated assets</li> <li>URI-based Identification: Each shard has a unique URI for easy persistence and loading</li> <li>Caching Support: Optional in-memory caching for frequently accessed shards</li> <li>Extensible: Easy to add custom shard types and loaders</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import tempfile\nfrom pathlib import Path\nfrom iden.dataset import create_vanilla_dataset\nfrom iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n\n# Create a simple dataset\nwith tempfile.TemporaryDirectory() as tmpdir:\n    # Create shards\n    train_tuple = create_shard_tuple(\n        [\n            create_json_shard(\n                [1, 2, 3], uri=Path(tmpdir).joinpath(\"train1.json\").as_uri()\n            ),\n            create_json_shard(\n                [4, 5, 6], uri=Path(tmpdir).joinpath(\"train2.json\").as_uri()\n            ),\n        ],\n        uri=Path(tmpdir).joinpath(\"train_tuple\").as_uri(),\n    )\n    val_tuple = create_shard_tuple(\n        [create_json_shard([7, 8, 9], uri=Path(tmpdir).joinpath(\"val1.json\").as_uri())],\n        uri=Path(tmpdir).joinpath(\"val_tuple\").as_uri(),\n    )\n\n    # Organize shards into splits\n    shards = create_shard_dict(\n        shards={\"train\": train_tuple, \"val\": val_tuple},\n        uri=Path(tmpdir).joinpath(\"shards\").as_uri(),\n    )\n    assets = create_shard_dict(shards={}, uri=Path(tmpdir).joinpath(\"assets\").as_uri())\n\n    # Create dataset\n    dataset = create_vanilla_dataset(\n        shards=shards,\n        assets=assets,\n        uri=Path(tmpdir).joinpath(\"my_dataset\").as_uri(),\n    )\n\n    # Access data\n    train_shards = dataset.get_shards(\"train\")\n    print(train_shards[0].get_data())  # Output: [1, 2, 3]\n</code></pre>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>iden</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>iden</code> to a new version will possibly break any code that was using the old version of <code>iden</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>iden</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep the system in order.</p>"},{"location":"get_started/#installing-with-uv-pip-recommended","title":"Installing with <code>uv pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>uv pip install iden\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>iden</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>uv pip install 'iden[all]'\n</code></pre> <p>This command also installs NumPy and PyTorch. It is also possible to install the optional packages manually or to select specific packages to install.</p>"},{"location":"get_started/#installing-specific-optional-dependencies","title":"Installing specific optional dependencies","text":"<p>You can install individual optional dependencies as needed:</p> <pre><code># Install with NumPy support\nuv pip install 'iden[numpy]'\n\n# Install with PyTorch support\nuv pip install 'iden[torch]'\n\n# Install with YAML support\nuv pip install 'iden[pyyaml]'\n\n# Install with safetensors support\nuv pip install 'iden[safetensors]'\n\n# Install with cloudpickle support\nuv pip install 'iden[cloudpickle]'\n\n# Install with joblib support\nuv pip install 'iden[joblib]'\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>iden</code> from source, you'll need <code>uv</code> for dependency management. If <code>uv</code> is not already installed, please refer to the uv installation guide.</p> <p>Then, clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/iden.git\ncd iden\n</code></pre> <p>It is recommended to create a Python 3.10+ virtual environment. This step is optional and can be skipped. To create a virtual environment, you can use <code>uv</code> to create a virtual environment:</p> <pre><code>make setup-venv\n</code></pre> <p>This will create a virtual environment using <code>uv</code> and install invoke for task management.</p>"},{"location":"get_started/#verifying-the-installation","title":"Verifying the installation","text":"<p>After installation, the required packages can be installed or updated with the following command:</p> <pre><code>inv install\n</code></pre> <p>Finally, the installation can be verified with the following command:</p> <pre><code>inv unit-test --cov\n</code></pre>"},{"location":"get_started/#development-workflow","title":"Development workflow","text":"<p>For contributors, the following commands are commonly used:</p>"},{"location":"get_started/#running-tests","title":"Running tests","text":"<pre><code># Run unit tests\ninv unit-test\n\n# Run unit tests with coverage\ninv unit-test --cov\n\n# Run integration tests\ninv integration-test\n\n# Run all tests\ninv all-test\n</code></pre>"},{"location":"get_started/#code-quality-checks","title":"Code quality checks","text":"<pre><code># Check code formatting\ninv check-format\n\n# Check linting\ninv check-lint\n\n# Check type hints\ninv check-types\n\n# Format docstrings\ninv docformat\n</code></pre>"},{"location":"get_started/#building-and-testing-documentation","title":"Building and testing documentation","text":"<pre><code># Install documentation dependencies (if not already installed)\ninv install --docs-deps\n\n# Build and serve documentation locally\ncd docs\nmkdocs serve\n</code></pre> <p>Then visit http://localhost:8000 in your browser.</p>"},{"location":"get_started/#managing-dependencies","title":"Managing dependencies","text":"<pre><code># Update all dependencies to latest versions\ninv update\n\n# Show installed packages\ninv show-installed-packages\n</code></pre> <p>For more detailed contribution guidelines, please refer to CONTRIBUTING.md.</p>"},{"location":"howto/dataset/","title":"Dataset","text":""},{"location":"howto/dataset/#how-to-implement-a-custom-dataset","title":"How to implement a custom dataset?","text":"<p>This section explains how to extend <code>iden</code> to support custom dataset implementations. <code>iden</code> provides a <code>BaseDataset</code> abstract class that can be extended to create custom dataset implementations.</p> <p>A new dataset can be implemented by extending the <code>iden.dataset.BaseDataset</code> class and implementing the required abstract methods:</p> <ul> <li><code>equal</code> - Compare two datasets for equality</li> <li><code>get_asset</code> - Get an asset by name</li> <li><code>get_num_shards</code> - Get the number of shards in a split</li> <li><code>get_shards</code> - Get all shards for a split</li> <li><code>get_splits</code> - Get all split names as a set</li> <li><code>get_uri</code> - Get the dataset URI</li> <li><code>has_asset</code> - Check if an asset exists</li> <li><code>has_split</code> - Check if a split exists</li> </ul>"},{"location":"howto/dataset/#example-custom-dataset-implementation","title":"Example: Custom dataset implementation","text":"<p>Here's a minimal example of a custom dataset:</p> <pre><code>from __future__ import annotations\n\nfrom typing import Any\n\nfrom iden.dataset.base import BaseDataset\nfrom iden.shard import BaseShard\n\n\nclass CustomDataset(BaseDataset[Any]):\n    \"\"\"Custom dataset implementation.\"\"\"\n\n    def __init__(self, uri: str, data: dict[str, list[BaseShard]]) -&gt; None:\n        self._uri = uri\n        self._data = data\n\n    def equal(self, other: object) -&gt; bool:\n        if not isinstance(other, CustomDataset):\n            return False\n        return self._uri == other._uri\n\n    def get_asset(self, asset: str) -&gt; BaseShard:\n        # Implement asset retrieval\n        raise NotImplementedError\n\n    def get_num_shards(self, split: str) -&gt; int:\n        return len(self._data.get(split, []))\n\n    def get_shards(self, split: str) -&gt; tuple[BaseShard[T], ...]:\n        # Return shards as a tuple\n        return tuple(self._data.get(split, []))\n\n    def get_splits(self) -&gt; set[str]:\n        return set(self._data.keys())\n\n    def get_uri(self) -&gt; str:\n        return self._uri\n\n    def has_asset(self, asset: str) -&gt; bool:\n        return False\n\n    def has_split(self, split: str) -&gt; bool:\n        return split in self._data\n</code></pre>"},{"location":"howto/dataset/#how-to-create-a-dataset-loader","title":"How to create a dataset loader?","text":"<p>Dataset loaders enable instantiating datasets from their URI configuration files. To create a custom loader, extend <code>iden.dataset.loader.BaseDatasetLoader</code>:</p> <pre><code>from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom iden.dataset.loader.base import BaseDatasetLoader\n\nif TYPE_CHECKING:\n    from iden.dataset import BaseDataset\n\n\nclass CustomDatasetLoader(BaseDatasetLoader):\n    \"\"\"Custom dataset loader.\"\"\"\n\n    def load(self, uri: str) -&gt; BaseDataset:\n        # Load dataset configuration from URI\n        # Instantiate and return the dataset\n        pass\n</code></pre>"},{"location":"howto/io/","title":"I/O Operations","text":""},{"location":"howto/io/#how-to-save-and-load-data","title":"How to save and load data?","text":"<p><code>iden</code> provides a flexible I/O system for saving and loading data in various formats.</p>"},{"location":"howto/io/#using-format-specific-functions","title":"Using format-specific functions","text":"<p>The simplest way to save and load data is using format-specific convenience functions:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json, load_json\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     # Save data\n...     save_json({\"key\": \"value\", \"numbers\": [1, 2, 3]}, path)\n...     # Load data\n...     data = load_json(path)\n...     data\n...\n{'key': 'value', 'numbers': [1, 2, 3]}\n</code></pre>"},{"location":"howto/io/#supported-formats","title":"Supported formats","text":"<p><code>iden</code> supports multiple data formats:</p> Format Save function Load function Required package JSON <code>save_json</code> <code>load_json</code> <code>json</code> (built-in) Pickle <code>save_pickle</code> <code>load_pickle</code> <code>pickle</code> (built-in) YAML <code>save_yaml</code> <code>load_yaml</code> <code>pyyaml</code> PyTorch <code>save_torch</code> <code>load_torch</code> <code>torch</code> Cloudpickle <code>save_cloudpickle</code> <code>load_cloudpickle</code> <code>cloudpickle</code> Joblib <code>save_joblib</code> <code>load_joblib</code> <code>joblib</code> Text <code>save_text</code> <code>load_text</code> -"},{"location":"howto/io/#example-yaml-format","title":"Example: YAML format","text":"<pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_yaml, load_yaml\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"config.yaml\")\n...     config = {\"model\": \"resnet50\", \"epochs\": 100, \"lr\": 0.001}\n...     save_yaml(config, path)\n...     loaded = load_yaml(path)\n...     loaded\n...\n{'epochs': 100, 'lr': 0.001, 'model': 'resnet50'}\n</code></pre>"},{"location":"howto/io/#example-pytorch-tensors","title":"Example: PyTorch tensors","text":"<pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from iden.io import save_torch, load_torch\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"model.pt\")\n...     data = {\"weights\": torch.randn(10, 10), \"bias\": torch.zeros(10)}\n...     save_torch(data, path)\n...     loaded = load_torch(path)\n...     loaded.keys()\n...\ndict_keys(['weights', 'bias'])\n</code></pre>"},{"location":"howto/io/#how-to-use-loaders-and-savers","title":"How to use loaders and savers?","text":"<p>For more control, you can use loader and saver classes directly:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import JsonSaver, JsonLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     # Create saver and save data\n...     saver = JsonSaver()\n...     saver.save({\"key\": \"value\"}, path)\n...     # Create loader and load data\n...     loader = JsonLoader()\n...     data = loader.load(path)\n...     data\n...\n{'key': 'value'}\n</code></pre>"},{"location":"howto/io/#how-to-register-custom-loaders","title":"How to register custom loaders?","text":"<p>You can register custom loaders for specific file extensions:</p> <pre><code>&gt;&gt;&gt; from iden.io import get_default_loader_registry, JsonLoader\n&gt;&gt;&gt; registry = get_default_loader_registry()\n&gt;&gt;&gt; # Register loader for .jsonl extension\n&gt;&gt;&gt; registry.register(\"jsonl\", JsonLoader())\n&gt;&gt;&gt; # Check registered loaders\n&gt;&gt;&gt; registry.has_loader(\"jsonl\")\nTrue\n</code></pre>"},{"location":"howto/io/#how-to-implement-a-custom-loader","title":"How to implement a custom loader?","text":"<p>To create a custom loader, extend the <code>BaseLoader</code> class:</p> <pre><code>from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Any\n\nfrom iden.io.base import BaseLoader\n\n\nclass CustomLoader(BaseLoader):\n    \"\"\"Custom data loader.\"\"\"\n\n    def load(self, path: Path) -&gt; Any:\n        \"\"\"Load data from path.\n\n        Args:\n            path: The path to load data from.\n\n        Returns:\n            The loaded data.\n        \"\"\"\n        # Implement custom loading logic\n        with open(path) as f:\n            data = f.read()\n        return self._process_data(data)\n\n    def _process_data(self, data: str) -&gt; Any:\n        \"\"\"Process raw data.\"\"\"\n        # Custom processing logic\n        return data\n</code></pre>"},{"location":"howto/io/#how-to-implement-a-custom-saver","title":"How to implement a custom saver?","text":"<p>To create a custom saver, extend the <code>BaseSaver</code> class:</p> <pre><code>from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Any\n\nfrom iden.io.base import BaseFileSaver\n\n\nclass CustomSaver(BaseFileSaver):\n    \"\"\"Custom data saver.\"\"\"\n\n    def save(self, data: Any, path: Path) -&gt; None:\n        \"\"\"Save data to path.\n\n        Args:\n            data: The data to save.\n            path: The path to save data to.\n        \"\"\"\n        # Ensure parent directory exists\n        self._create_parent_dir(path)\n\n        # Implement custom saving logic\n        processed = self._process_data(data)\n        with open(path, \"w\") as f:\n            f.write(processed)\n\n    def _process_data(self, data: Any) -&gt; str:\n        \"\"\"Process data before saving.\"\"\"\n        # Custom processing logic\n        return str(data)\n</code></pre>"},{"location":"howto/shard/","title":"Shard","text":""},{"location":"howto/shard/#how-to-implement-a-new-shard","title":"How to implement a new shard?","text":"<p>This section explains how to extend <code>iden</code> to support more shard implementations. <code>iden</code> has some built-in shard implementations, but it is quite easy to add additional implementations. A new shard can be implemented by extending the <code>iden.shard.BaseShard</code> class and implementing the following 5 methods:</p> <ul> <li><code>clear</code></li> <li><code>equal</code></li> <li><code>get_data</code></li> <li><code>get_uri</code></li> <li><code>is_cached</code></li> </ul> <p>Ideally, the instantiation of a shard object should be lightweight and the data should be loaded in-memory only when the <code>get_data</code> is called.</p>"},{"location":"refs/constants/","title":"iden.constants","text":""},{"location":"refs/constants/#iden.constants","title":"iden.constants","text":"<p>Contain the main constants.</p>"},{"location":"refs/data/","title":"iden.data","text":""},{"location":"refs/data/#iden.data.generator","title":"iden.data.generator","text":"<p>Contain data generator implementations.</p>"},{"location":"refs/data/#iden.data.generator.BaseDataGenerator","title":"iden.data.generator.BaseDataGenerator","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to generate data.</p> Example <pre><code>&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; generator = DataGenerator([1, 2, 3])\n&gt;&gt;&gt; generator\nDataGenerator(copy=False)\n&gt;&gt;&gt; generator.generate()\n[1, 2, 3]\n</code></pre>"},{"location":"refs/data/#iden.data.generator.BaseDataGenerator.equal","title":"iden.data.generator.BaseDataGenerator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare with.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; DataGenerator([1, 2, 3]).equal(DataGenerator([1, 2, 3]))\nTrue\n&gt;&gt;&gt; DataGenerator([1, 2, 3]).equal(DataGenerator([]))\nFalse\n</code></pre>"},{"location":"refs/data/#iden.data.generator.BaseDataGenerator.generate","title":"iden.data.generator.BaseDataGenerator.generate  <code>abstractmethod</code>","text":"<pre><code>generate() -&gt; T\n</code></pre> <p>Generate data.</p> <p>Returns:</p> Type Description <code>T</code> <p>The generated data.</p> Example <pre><code>&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; generator = DataGenerator([1, 2, 3])\n&gt;&gt;&gt; generator.generate()\n[1, 2, 3]\n</code></pre>"},{"location":"refs/data/#iden.data.generator.DataGenerator","title":"iden.data.generator.DataGenerator","text":"<p>               Bases: <code>BaseDataGenerator[T]</code></p> <p>Implement a simple data generator that wraps existing data.</p> <p>This generator provides a straightforward way to create data on demand by storing and optionally copying the data when requested.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data to return.</p> required <code>copy</code> <code>bool</code> <p>If <code>True</code>, it returns a copy of the data, otherwise it always returns the same data.</p> <code>False</code> Example <pre><code>&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; generator = DataGenerator([1, 2, 3])\n&gt;&gt;&gt; generator\nDataGenerator(copy=False)\n&gt;&gt;&gt; generator.generate()\n[1, 2, 3]\n</code></pre>"},{"location":"refs/data/#iden.data.generator.is_data_generator_config","title":"iden.data.generator.is_data_generator_config","text":"<pre><code>is_data_generator_config(config: dict[Any, Any]) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseDataGenerator</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[Any, Any]</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseDataGenerator</code> object.</p> Example <pre><code>&gt;&gt;&gt; from iden.data.generator import is_data_generator_config\n&gt;&gt;&gt; is_data_generator_config({\"_target_\": \"iden.data.generator.DataGenerator\"})\nTrue\n</code></pre>"},{"location":"refs/data/#iden.data.generator.setup_data_generator","title":"iden.data.generator.setup_data_generator","text":"<pre><code>setup_data_generator(\n    data_generator: BaseDataGenerator[T] | dict[Any, Any],\n) -&gt; BaseDataGenerator[T]\n</code></pre> <p>Set up a data generator.</p> <p>The data generator is instantiated from its configuration by using the <code>BaseDataGenerator</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>data_generator</code> <code>BaseDataGenerator[T] | dict[Any, Any]</code> <p>The data generator or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseDataGenerator[T]</code> <p>The instantiated data generator.</p> Example <pre><code>&gt;&gt;&gt; from iden.data.generator import is_data_generator_config\n&gt;&gt;&gt; generator = setup_data_generator(\n...     {\"_target_\": \"iden.data.generator.DataGenerator\", \"data\": [1, 2, 3]}\n... )\n&gt;&gt;&gt; generator\nDataGenerator(copy=False)\n</code></pre>"},{"location":"refs/dataset/","title":"iden.dataset","text":""},{"location":"refs/dataset/#iden.dataset","title":"iden.dataset","text":"<p>Contain dataset implementations.</p>"},{"location":"refs/dataset/#iden.dataset.BaseDataset","title":"iden.dataset.BaseDataset","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a dataset.</p> <p>Note this dataset class is very different from the PyTorch dataset class because it has a different goal. One of the goals is to help to organize and manage shards.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 [1, 2, 3], uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     dataset = VanillaDataset(\n...         uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards, assets=assets\n...     )\n...     dataset\n...\nVanillaDataset(\n  (uri): file:///.../uri\n  (shards): ShardDict(\n      (uri): file:///.../uri_shards\n      (shards):\n        (train): ShardTuple(\n            (uri): file:///.../uri_train\n            (shards):\n              (0): JsonShard(uri=file:///.../shard/uri1)\n              (1): JsonShard(uri=file:///.../shard/uri2)\n          )\n        (val): ShardTuple(\n            (uri): file:///.../uri_val\n            (shards):\n          )\n    )\n  (assets): ShardDict(\n      (uri): file:///.../uri_assets\n      (shards):\n        (stats): JsonShard(uri=file:///.../uri_stats)\n    )\n)\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.BaseDataset.equal","title":"iden.dataset.BaseDataset.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two datasets are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare with.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two datasets are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 [1, 2, 3], uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     dataset1 = VanillaDataset(\n...         uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards, assets=assets\n...     )\n...     dataset2 = VanillaDataset(\n...         uri=Path(tmpdir).joinpath(\"uri2\").as_uri(), shards=shards, assets=assets\n...     )\n...     dataset1.equal(dataset2)\n...\nFalse\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.BaseDataset.get_asset","title":"iden.dataset.BaseDataset.get_asset  <code>abstractmethod</code>","text":"<pre><code>get_asset(asset_id: str) -&gt; Any\n</code></pre> <p>Get a data asset from this sharded dataset.</p> <p>This method is useful to access some data variables/parameters that are not available before to load/preprocess the data.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>The asset ID used to find the asset.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The asset.</p> <p>Raises:</p> Type Description <code>AssetNotFoundError</code> <p>if the asset does not exist.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 {\"mean\": 42}, uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     dataset = VanillaDataset(\n...         uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards, assets=assets\n...     )\n...     dataset.get_asset(\"stats\").get_data()\n...\n{'mean': 42}\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.BaseDataset.get_num_shards","title":"iden.dataset.BaseDataset.get_num_shards  <code>abstractmethod</code>","text":"<pre><code>get_num_shards(split: str) -&gt; int\n</code></pre> <p>Get the number of shards for a given split.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of shards in the dataset for a given split.</p> <p>Raises:</p> Type Description <code>SplitNotFoundError</code> <p>if the split does not exist.</p> <p>Returns:</p> Type Description <code>int</code> <p>The dataset splits.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 {\"mean\": 42}, uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     dataset = VanillaDataset(\n...         uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards, assets=assets\n...     )\n...     dataset.get_num_shards(\"train\")\n...     dataset.get_num_shards(\"val\")\n...\n2\n0\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.BaseDataset.get_shards","title":"iden.dataset.BaseDataset.get_shards  <code>abstractmethod</code>","text":"<pre><code>get_shards(split: str) -&gt; tuple[BaseShard[T], ...]\n</code></pre> <p>Get the shards for a given split.</p> <p>Returns:</p> Type Description <code>tuple[BaseShard[T], ...]</code> <p>The shards for a given split. The shards are sorted by ascending order of URI.</p> <p>Raises:</p> Type Description <code>SplitNotFoundError</code> <p>if the split does not exist.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 {\"mean\": 42}, uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     dataset = VanillaDataset(\n...         uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards, assets=assets\n...     )\n...     dataset.get_shards(\"train\")\n...     dataset.get_shards(\"val\")\n...\n(JsonShard(uri=file:///.../uri1), JsonShard(uri=file:///.../uri2))\n()\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.BaseDataset.get_splits","title":"iden.dataset.BaseDataset.get_splits  <code>abstractmethod</code>","text":"<pre><code>get_splits() -&gt; set[str]\n</code></pre> <p>Get the available dataset splits.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>The dataset splits.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 {\"mean\": 42}, uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     dataset = VanillaDataset(\n...         uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards, assets=assets\n...     )\n...     sorted(dataset.get_splits())\n...\n['train', 'val']\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.BaseDataset.get_uri","title":"iden.dataset.BaseDataset.get_uri  <code>abstractmethod</code>","text":"<pre><code>get_uri() -&gt; str\n</code></pre> <p>Get the Uniform Resource Identifier (URI) of the dataset.</p> <p>Returns:</p> Type Description <code>str</code> <p>The dataset's URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 {\"mean\": 42}, uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     dataset = VanillaDataset(\n...         uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards, assets=assets\n...     )\n...     dataset.get_uri()\n...\nfile:///.../uri\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.BaseDataset.has_asset","title":"iden.dataset.BaseDataset.has_asset  <code>abstractmethod</code>","text":"<pre><code>has_asset(asset_id: str) -&gt; bool\n</code></pre> <p>Indicate if the asset exists or not.</p> <p>Parameters:</p> Name Type Description Default <code>asset_id</code> <code>str</code> <p>The asset ID used to find the asset.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the asset exists, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 {\"mean\": 42}, uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     dataset = VanillaDataset(\n...         uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards, assets=assets\n...     )\n...     dataset.has_asset(\"stats\")\n...     dataset.has_asset(\"missing\")\n...\nTrue\nFalse\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.BaseDataset.has_split","title":"iden.dataset.BaseDataset.has_split  <code>abstractmethod</code>","text":"<pre><code>has_split(split: str) -&gt; bool\n</code></pre> <p>Indicate if a dataset split exists or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> of the split exists, otherwise <code>False</code></p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 {\"mean\": 42}, uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     dataset = VanillaDataset(\n...         uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards, assets=assets\n...     )\n...     dataset.has_split(\"train\")\n...     dataset.has_split(\"missing\")\n...\nTrue\nFalse\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.VanillaDataset","title":"iden.dataset.VanillaDataset","text":"<p>               Bases: <code>BaseDataset[T]</code></p> <p>Implement a simple dataset for managing shards and assets.</p> <p>This dataset provides a straightforward implementation for organizing data into shards (training, validation, test splits) and assets (metadata, statistics, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The Uniform Resource Identifier (URI) associated with the dataset, used for identification and persistence.</p> required <code>shards</code> <code>ShardDict[ShardTuple[T]]</code> <p>The dataset's shards. Each item in the mapping represent a dataset split, where the key is the dataset split and the value is the shards.</p> required <code>assets</code> <code>ShardDict[Any]</code> <p>The dataset's assets.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 [1, 2, 3], uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     dataset = VanillaDataset(\n...         uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards, assets=assets\n...     )\n...     dataset\n...\nVanillaDataset(\n  (uri): file:///.../uri\n  (shards): ShardDict(\n      (uri): file:///.../uri_shards\n      (shards):\n        (train): ShardTuple(\n            (uri): file:///.../uri_train\n            (shards):\n              (0): JsonShard(uri=file:///.../shard/uri1)\n              (1): JsonShard(uri=file:///.../shard/uri2)\n          )\n        (val): ShardTuple(\n            (uri): file:///.../uri_val\n            (shards):\n          )\n    )\n  (assets): ShardDict(\n      (uri): file:///.../uri_assets\n      (shards):\n        (stats): JsonShard(uri=file:///.../uri_stats)\n    )\n)\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.VanillaDataset.from_uri","title":"iden.dataset.VanillaDataset.from_uri  <code>classmethod</code>","text":"<pre><code>from_uri(uri: str) -&gt; VanillaDataset[T]\n</code></pre> <p>Instantiate a shard from its URI.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The Uniform Resource Identifier (URI) of the dataset to load.</p> required <p>Returns:</p> Type Description <code>VanillaDataset[T]</code> <p>The instantiated shard.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import create_vanilla_dataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 [1, 2, 3], uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     uri = Path(tmpdir).joinpath(\"uri\").as_uri()\n...     create_vanilla_dataset(uri=uri, shards=shards, assets=assets)\n...     dataset = VanillaDataset.from_uri(uri)\n...     dataset\n...\nVanillaDataset(\n  (uri): file:///.../uri\n  (shards): ShardDict(\n      (uri): file:///.../uri_shards\n      (shards):\n        (train): ShardTuple(\n            (uri): file:///.../uri_train\n            (shards):\n              (0): JsonShard(uri=file:///.../shard/uri1)\n              (1): JsonShard(uri=file:///.../shard/uri2)\n          )\n        (val): ShardTuple(\n            (uri): file:///.../uri_val\n            (shards):\n          )\n    )\n  (assets): ShardDict(\n      (uri): file:///.../uri_assets\n      (shards):\n        (stats): JsonShard(uri=file:///.../uri_stats)\n    )\n)\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.VanillaDataset.generate_uri_config","title":"iden.dataset.VanillaDataset.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(\n    shards: ShardDict[ShardTuple[BaseShard[T]]],\n    assets: ShardDict[Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the dataset from its URI.</p> <p>The config must be compatible with the JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>shards</code> <code>ShardDict[ShardTuple[BaseShard[T]]]</code> <p>The shards in the dataset. Each item in the mapping represent a dataset split, where the key is the dataset split and the value is the shards.</p> required <code>assets</code> <code>ShardDict[Any]</code> <p>The dataset's assets.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 [1, 2, 3], uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     config = VanillaDataset.generate_uri_config(shards=shards, assets=assets)\n...     config\n...\n{'loader': {'_target_': 'iden.dataset.loader.VanillaDatasetLoader'},\n 'shards': 'file:///.../uri_shards',\n 'assets': 'file:///.../uri_assets'}\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.create_vanilla_dataset","title":"iden.dataset.create_vanilla_dataset","text":"<pre><code>create_vanilla_dataset(\n    shards: ShardDict[ShardTuple[BaseShard[T]]],\n    assets: ShardDict[Any],\n    uri: str,\n) -&gt; VanillaDataset[T]\n</code></pre> <p>Create a <code>VanillaDataset</code> from its shards.</p> Note <p>It is a utility function to create a <code>VanillaDataset</code> from     its shards and URI. It is possible to create a     <code>VanillaDataset</code> in other ways.</p> <p>Parameters:</p> Name Type Description Default <code>shards</code> <code>ShardDict[ShardTuple[BaseShard[T]]]</code> <p>The dataset's shards. Each item in the mapping represent a dataset split, where the key is the dataset split and the value is the shards.</p> required <code>assets</code> <code>ShardDict[Any]</code> <p>The dataset's assets.</p> required <code>uri</code> <code>str</code> <p>The URI associated to the dataset.</p> required <p>Returns:</p> Type Description <code>VanillaDataset[T]</code> <p>The instantited <code>VanillaDataset</code> object.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import create_vanilla_dataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 [1, 2, 3], uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     dataset = create_vanilla_dataset(\n...         uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards, assets=assets\n...     )\n...     dataset\n...\nVanillaDataset(\n  (uri): file:///.../uri\n  (shards): ShardDict(\n      (uri): file:///.../uri_shards\n      (shards):\n        (train): ShardTuple(\n            (uri): file:///.../uri_train\n            (shards):\n              (0): JsonShard(uri=file:///.../shard/uri1)\n              (1): JsonShard(uri=file:///.../shard/uri2)\n          )\n        (val): ShardTuple(\n            (uri): file:///.../uri_val\n            (shards):\n          )\n    )\n  (assets): ShardDict(\n      (uri): file:///.../uri_assets\n      (shards):\n        (stats): JsonShard(uri=file:///.../uri_stats)\n    )\n)\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.load_from_uri","title":"iden.dataset.load_from_uri","text":"<pre><code>load_from_uri(uri: str) -&gt; BaseDataset[T]\n</code></pre> <p>Load a dataset from its Uniform Resource Identifier (URI).</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The URI of the dataset.</p> required <p>Returns:</p> Type Description <code>BaseDataset[T]</code> <p>The dataset associated to the URI.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the URI file does not exist.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import create_vanilla_dataset, load_from_uri\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 [1, 2, 3], uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     uri = Path(tmpdir).joinpath(\"uri\").as_uri()\n...     create_vanilla_dataset(uri=uri, shards=shards, assets=assets)\n...     dataset = load_from_uri(uri)\n...     dataset\n...\nVanillaDataset(\n  (uri): file:///.../uri\n  (shards): ShardDict(\n      (uri): file:///.../uri_shards\n      (shards):\n        (train): ShardTuple(\n            (uri): file:///.../uri_train\n            (shards):\n              (0): JsonShard(uri=file:///.../shard/uri1)\n              (1): JsonShard(uri=file:///.../shard/uri2)\n          )\n        (val): ShardTuple(\n            (uri): file:///.../uri_val\n            (shards):\n          )\n    )\n  (assets): ShardDict(\n      (uri): file:///.../uri_assets\n      (shards):\n        (stats): JsonShard(uri=file:///.../uri_stats)\n    )\n)\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.generator","title":"iden.dataset.generator","text":"<p>Contain dataset generator implementations.</p>"},{"location":"refs/dataset/#iden.dataset.generator.BaseDatasetGenerator","title":"iden.dataset.generator.BaseDatasetGenerator","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to create a dataset.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset.generator import VanillaDatasetGenerator\n&gt;&gt;&gt; from iden.shard.generator import ShardDictGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = VanillaDatasetGenerator(\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         shards=ShardDictGenerator(\n...             path_uri=Path(tmpdir).joinpath(\"uri/shards\"), shards={}\n...         ),\n...         assets=ShardDictGenerator(\n...             path_uri=Path(tmpdir).joinpath(\"uri/assets\"), shards={}\n...         ),\n...     )\n...     generator\n...     dataset = generator.generate(\"dataset1\")\n...     dataset\n...\nVanillaDatasetGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (shards): ShardDictGenerator(\n      (path_uri): PosixPath('/.../uri/shards')\n      (shards):\n    )\n  (assets): ShardDictGenerator(\n      (path_uri): PosixPath('/.../uri/assets')\n      (shards):\n    )\n)\nVanillaDataset(\n  (uri): file:///.../uri/dataset1\n  (shards): ShardDict(\n      (uri): file:///.../uri/shards/shards\n      (shards):\n    )\n  (assets): ShardDict(\n      (uri): file:///.../uri/assets/assets\n      (shards):\n    )\n)\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.generator.BaseDatasetGenerator.equal","title":"iden.dataset.generator.BaseDatasetGenerator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare with.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset.generator import VanillaDatasetGenerator\n&gt;&gt;&gt; from iden.shard.generator import ShardDictGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = ShardDictGenerator(path_uri=Path(tmpdir).joinpath(\"uri/shards\"), shards={})\n...     assets = ShardDictGenerator(path_uri=Path(tmpdir).joinpath(\"uri/assets\"), shards={})\n...     generator1 = VanillaDatasetGenerator(\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         shards=shards,\n...         assets=assets,\n...     )\n...     generator2 = VanillaDatasetGenerator(\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         shards=shards,\n...         assets=assets,\n...     )\n...     generator3 = VanillaDatasetGenerator(\n...         path_uri=Path(tmpdir).joinpath(\"uri2\"),\n...         shards=shards,\n...         assets=assets,\n...     )\n...     generator1.equal(generator2)\n...     generator1.equal(generator3)\n...\nTrue\nFalse\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.generator.BaseDatasetGenerator.generate","title":"iden.dataset.generator.BaseDatasetGenerator.generate  <code>abstractmethod</code>","text":"<pre><code>generate(dataset_id: str) -&gt; BaseDataset[T]\n</code></pre> <p>Generate a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>str</code> <p>The dataset IDI.</p> required <p>Returns:</p> Type Description <code>BaseDataset[T]</code> <p>The generated dataset.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset.generator import VanillaDatasetGenerator\n&gt;&gt;&gt; from iden.shard.generator import ShardDictGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = VanillaDatasetGenerator(\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         shards=ShardDictGenerator(\n...             path_uri=Path(tmpdir).joinpath(\"uri/shards\"), shards={}\n...         ),\n...         assets=ShardDictGenerator(\n...             path_uri=Path(tmpdir).joinpath(\"uri/assets\"), shards={}\n...         ),\n...     )\n...     dataset = generator.generate(\"dataset1\")\n...     dataset\n...\nVanillaDataset(\n  (uri): file:///.../uri/dataset1\n  (shards): ShardDict(\n      (uri): file:///.../uri/shards/shards\n      (shards):\n    )\n  (assets): ShardDict(\n      (uri): file:///.../uri/assets/assets\n      (shards):\n    )\n)\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.generator.VanillaDatasetGenerator","title":"iden.dataset.generator.VanillaDatasetGenerator","text":"<p>               Bases: <code>BaseDatasetGenerator[tuple[BaseShard[T], ...]]</code></p> <p>Implement a <code>VanillaDataset</code> generator.</p> <p>Parameters:</p> Name Type Description Default <code>path_uri</code> <code>Path</code> <p>The path where to save the URI file.</p> required <code>shards</code> <code>ShardDictGenerator[T] | dict[Any, Any]</code> <p>The shards generator or its configuration.</p> required <code>assets</code> <code>ShardDictGenerator[Any] | dict[Any, Any]</code> <p>The assets generator or its configuration.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset.generator import VanillaDatasetGenerator\n&gt;&gt;&gt; from iden.shard.generator import ShardDictGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = VanillaDatasetGenerator(\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         shards=ShardDictGenerator(\n...             path_uri=Path(tmpdir).joinpath(\"uri/shards\"), shards={}\n...         ),\n...         assets=ShardDictGenerator(\n...             path_uri=Path(tmpdir).joinpath(\"uri/assets\"), shards={}\n...         ),\n...     )\n...     generator\n...     dataset = generator.generate(\"dataset1\")\n...     dataset\n...\nVanillaDatasetGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (shards): ShardDictGenerator(\n      (path_uri): PosixPath('/.../uri/shards')\n      (shards):\n    )\n  (assets): ShardDictGenerator(\n      (path_uri): PosixPath('/.../uri/assets')\n      (shards):\n    )\n)\nVanillaDataset(\n  (uri): file:///.../uri/dataset1\n  (shards): ShardDict(\n      (uri): file:///.../uri/shards/shards\n      (shards):\n    )\n  (assets): ShardDict(\n      (uri): file:///.../uri/assets/assets\n      (shards):\n    )\n)\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.generator.is_dataset_generator_config","title":"iden.dataset.generator.is_dataset_generator_config","text":"<pre><code>is_dataset_generator_config(config: dict[Any, Any]) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseDatasetGenerator</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[Any, Any]</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseDatasetGenerator</code> object.</p> Example <pre><code>&gt;&gt;&gt; from iden.dataset.generator import is_dataset_generator_config\n&gt;&gt;&gt; is_dataset_generator_config(\n...     {\"_target_\": \"iden.dataset.generator.VanillaDatasetGenerator\"}\n... )\nTrue\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.generator.setup_dataset_generator","title":"iden.dataset.generator.setup_dataset_generator","text":"<pre><code>setup_dataset_generator(\n    dataset_generator: (\n        BaseDatasetGenerator[T] | dict[Any, Any]\n    ),\n) -&gt; BaseDatasetGenerator[T]\n</code></pre> <p>Set up a dataset generator.</p> <p>The dataset generator is instantiated from its configuration by using the <code>BaseDatasetGenerator</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_generator</code> <code>BaseDatasetGenerator[T] | dict[Any, Any]</code> <p>The dataset generator or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseDatasetGenerator[T]</code> <p>The instantiated dataset generator.</p> <p>Example: <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset.generator import setup_dataset_generator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = setup_dataset_generator(\n...         {\n...             \"_target_\": \"iden.dataset.generator.VanillaDatasetGenerator\",\n...             \"path_uri\": Path(tmpdir).joinpath(\"uri\"),\n...             \"shards\": {\n...                 \"_target_\": \"iden.shard.generator.ShardDictGenerator\",\n...                 \"path_uri\": Path(tmpdir).joinpath(\"uri/shards\"),\n...                 \"shards\": {},\n...             },\n...             \"assets\": {\n...                 \"_target_\": \"iden.shard.generator.ShardDictGenerator\",\n...                 \"path_uri\": Path(tmpdir).joinpath(\"uri/assets\"),\n...                 \"shards\": {},\n...             },\n...         }\n...     )\n...     generator\n...\nVanillaDatasetGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (shards): ShardDictGenerator(\n      (path_uri): PosixPath('/.../uri/shards')\n      (shards):\n    )\n  (assets): ShardDictGenerator(\n      (path_uri): PosixPath('/.../uri/assets')\n      (shards):\n    )\n)\n</code></pre></p>"},{"location":"refs/dataset/#iden.dataset.loader","title":"iden.dataset.loader","text":"<p>Contain dataset loader implementations.</p>"},{"location":"refs/dataset/#iden.dataset.loader.BaseDatasetLoader","title":"iden.dataset.loader.BaseDatasetLoader","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a dataset loader.</p> <p>A dataset loader object allows to load a <code>BaseDataset</code> object from its Uniform Resource Identifier (URI).</p> Example <pre><code>&gt;&gt;&gt; from iden.dataset.loader import VanillaDatasetLoader\n&gt;&gt;&gt; loader = VanillaDatasetLoader()\n&gt;&gt;&gt; loader\nVanillaDatasetLoader()\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.loader.BaseDatasetLoader.equal","title":"iden.dataset.loader.BaseDatasetLoader.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare with.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.dataset.loader import VanillaDatasetLoader\n&gt;&gt;&gt; VanillaDatasetLoader().equal(VanillaDatasetLoader())\nTrue\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.loader.BaseDatasetLoader.load","title":"iden.dataset.loader.BaseDatasetLoader.load  <code>abstractmethod</code>","text":"<pre><code>load(uri: str) -&gt; BaseDataset[T]\n</code></pre> <p>Load a dataset from its Uniform Resource Identifier (URI).</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The URI of the dataset to load.</p> required <p>Returns:</p> Type Description <code>BaseDataset[T]</code> <p>The loaded dataset.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import create_vanilla_dataset\n&gt;&gt;&gt; from iden.dataset.loader import VanillaDatasetLoader\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 [1, 2, 3], uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     uri = Path(tmpdir).joinpath(\"uri\").as_uri()\n...     create_vanilla_dataset(uri=uri, shards=shards, assets=assets)\n...     loader = VanillaDatasetLoader()\n...     dataset = loader.load(uri)\n...     dataset\n...\nVanillaDataset(\n  (uri): file:///.../uri\n  (shards): ShardDict(\n      (uri): file:///.../uri_shards\n      (shards):\n        (train): ShardTuple(\n            (uri): file:///.../uri_train\n            (shards):\n              (0): JsonShard(uri=file:///.../shard/uri1)\n              (1): JsonShard(uri=file:///.../shard/uri2)\n          )\n        (val): ShardTuple(\n            (uri): file:///.../uri_val\n            (shards):\n          )\n    )\n  (assets): ShardDict(\n      (uri): file:///.../uri_assets\n      (shards):\n        (stats): JsonShard(uri=file:///.../uri_stats)\n    )\n)\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.loader.VanillaDatasetLoader","title":"iden.dataset.loader.VanillaDatasetLoader","text":"<p>               Bases: <code>BaseDatasetLoader[T]</code></p> <p>Implement a <code>VanillaDatasetLoader</code> loader.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import create_vanilla_dataset\n&gt;&gt;&gt; from iden.dataset.loader import VanillaDatasetLoader\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...                     ),\n...                     create_json_shard(\n...                         [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...                     ),\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"uri_train\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 shards=[],\n...                 uri=Path(tmpdir).joinpath(\"uri_val\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={\n...             \"stats\": create_json_shard(\n...                 [1, 2, 3], uri=Path(tmpdir).joinpath(\"uri_stats\").as_uri()\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"uri_assets\").as_uri(),\n...     )\n...     uri = Path(tmpdir).joinpath(\"uri\").as_uri()\n...     create_vanilla_dataset(uri=uri, shards=shards, assets=assets)\n...     loader = VanillaDatasetLoader()\n...     dataset = loader.load(uri)\n...     dataset\n...\nVanillaDataset(\n  (uri): file:///.../uri\n  (shards): ShardDict(\n      (uri): file:///.../uri_shards\n      (shards):\n        (train): ShardTuple(\n            (uri): file:///.../uri_train\n            (shards):\n              (0): JsonShard(uri=file:///.../shard/uri1)\n              (1): JsonShard(uri=file:///.../shard/uri2)\n          )\n        (val): ShardTuple(\n            (uri): file:///.../uri_val\n            (shards):\n          )\n    )\n  (assets): ShardDict(\n      (uri): file:///.../uri_assets\n      (shards):\n        (stats): JsonShard(uri=file:///.../uri_stats)\n    )\n)\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.loader.is_dataset_loader_config","title":"iden.dataset.loader.is_dataset_loader_config","text":"<pre><code>is_dataset_loader_config(config: dict[Any, Any]) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseDatasetLoader</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[Any, Any]</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseDatasetLoader</code> object.</p> Example <pre><code>&gt;&gt;&gt; from iden.dataset.loader import is_dataset_loader_config\n&gt;&gt;&gt; is_dataset_loader_config({\"_target_\": \"iden.dataset.loader.VanillaDatasetLoader\"})\nTrue\n</code></pre>"},{"location":"refs/dataset/#iden.dataset.loader.setup_dataset_loader","title":"iden.dataset.loader.setup_dataset_loader","text":"<pre><code>setup_dataset_loader(\n    dataset_loader: BaseDatasetLoader[T] | dict[Any, Any],\n) -&gt; BaseDatasetLoader[T]\n</code></pre> <p>Set up a dataset loader.</p> <p>The dataset loader is instantiated from its configuration by using the <code>BaseDatasetLoader</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_loader</code> <code>BaseDatasetLoader[T] | dict[Any, Any]</code> <p>The dataset loader or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseDatasetLoader[T]</code> <p>The instantiated dataset loader.</p> Example <pre><code>&gt;&gt;&gt; from iden.dataset.loader import setup_dataset_loader\n&gt;&gt;&gt; dataset_loader = setup_dataset_loader(\n...     {\"_target_\": \"iden.dataset.loader.VanillaDatasetLoader\"}\n... )\n&gt;&gt;&gt; dataset_loader\nVanillaDatasetLoader()\n</code></pre>"},{"location":"refs/io/","title":"iden.io","text":""},{"location":"refs/io/#iden.io","title":"iden.io","text":"<p>Contain data loaders and savers.</p>"},{"location":"refs/io/#iden.io.BaseFileSaver","title":"iden.io.BaseFileSaver","text":"<p>               Bases: <code>BaseSaver[T]</code></p> <p>Define the base class to implement a file saver.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import JsonSaver, JsonLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     JsonSaver().save({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = JsonLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.BaseFileSaver.save","title":"iden.io.BaseFileSaver.save","text":"<pre><code>save(\n    to_save: T, path: Path, *, exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Save the data into the given path.</p> <p>Parameters:</p> Name Type Description Default <code>to_save</code> <code>T</code> <p>The data to save. The data should be compatible with the saving engine.</p> required <code>path</code> <code>Path</code> <p>The path where to save the data.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>exist_ok</code> is <code>False</code> (the default), <code>FileExistsError</code> is raised if the target file already exists. If <code>exist_ok</code> is <code>True</code>, <code>FileExistsError</code> will not be raised unless the given path already exists in the file system and is not a file.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>if the file already exists.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import JsonSaver, JsonLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     JsonSaver().save({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = JsonLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.BaseLoader","title":"iden.io.BaseLoader","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a data loader.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json, JsonLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     save_json({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = JsonLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.BaseLoader.equal","title":"iden.io.BaseLoader.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare with.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.io import JsonLoader, YamlLoader\n&gt;&gt;&gt; JsonLoader().equal(JsonLoader())\nTrue\n&gt;&gt;&gt; JsonLoader().equal(YamlLoader())\nFalse\n</code></pre>"},{"location":"refs/io/#iden.io.BaseLoader.load","title":"iden.io.BaseLoader.load  <code>abstractmethod</code>","text":"<pre><code>load(path: Path) -&gt; T\n</code></pre> <p>Load the data from the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path with the data to load.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The data</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json, JsonLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     save_json({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = JsonLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.BaseSaver","title":"iden.io.BaseSaver","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a data saver.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import JsonSaver, JsonLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     JsonSaver().save({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = JsonLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.BaseSaver.equal","title":"iden.io.BaseSaver.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare with.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.io import JsonSaver, YamlSaver\n&gt;&gt;&gt; JsonSaver().equal(JsonSaver())\nTrue\n&gt;&gt;&gt; JsonSaver().equal(YamlSaver())\nFalse\n</code></pre>"},{"location":"refs/io/#iden.io.BaseSaver.save","title":"iden.io.BaseSaver.save  <code>abstractmethod</code>","text":"<pre><code>save(\n    to_save: T, path: Path, *, exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Save the data into the given path.</p> <p>Parameters:</p> Name Type Description Default <code>to_save</code> <code>T</code> <p>The data to save. The data should be compatible with the saving engine.</p> required <code>path</code> <code>Path</code> <p>The path where to save the data.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>exist_ok</code> is <code>False</code> (the default), an exception is raised if the target path already exists.</p> <code>False</code> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import JsonSaver, JsonLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     JsonSaver().save({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = JsonLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.CloudpickleLoader","title":"iden.io.CloudpickleLoader","text":"<p>               Bases: <code>BaseLoader[Any]</code></p> <p>Implement a data loader to load data in a pickle file with cloudpickle.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_cloudpickle, CloudpickleLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pkl\")\n...     save_cloudpickle({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = CloudpickleLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.CloudpickleSaver","title":"iden.io.CloudpickleSaver","text":"<p>               Bases: <code>BaseFileSaver[Any]</code></p> <p>Implement a file saver to save data with a pickle file with cloudpickle.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>cloudpickle.dump</code>.</p> <code>{}</code> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import CloudpickleSaver, CloudpickleLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pkl\")\n...     CloudpickleSaver().save({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = CloudpickleLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.JoblibLoader","title":"iden.io.JoblibLoader","text":"<p>               Bases: <code>BaseLoader[T]</code></p> <p>Implement a data loader to load data in a pickle file with joblib.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_joblib, JoblibLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.joblib\")\n...     save_joblib({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = JoblibLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.JoblibSaver","title":"iden.io.JoblibSaver","text":"<p>               Bases: <code>BaseFileSaver[T]</code></p> <p>Implement a file saver to save data with a pickle file with joblib.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>joblib.dump</code>.</p> <code>{}</code> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import JoblibSaver, JoblibLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.joblib\")\n...     JoblibSaver().save({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = JoblibLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.JsonLoader","title":"iden.io.JsonLoader","text":"<p>               Bases: <code>BaseLoader[T]</code></p> <p>Implement a data loader to load data in a JSON file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json, JsonLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     save_json({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = JsonLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.JsonSaver","title":"iden.io.JsonSaver","text":"<p>               Bases: <code>BaseFileSaver[T]</code></p> <p>Implement a file saver to save data with a JSON file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import JsonSaver, JsonLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     JsonSaver().save({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = JsonLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.LoaderRegistry","title":"iden.io.LoaderRegistry","text":"<p>               Bases: <code>BaseLoader[Any]</code></p> <p>Registry that manages and dispatches loaders based on file extension.</p> <p>This registry maps file extensions (e.g., \"json\", \"txt\") to loader instances that handle loading files with those extensions. It provides automatic dispatching to the appropriate loader based on a file's extension.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>dict[str, BaseLoader[Any]] | None</code> <p>Optional initial mapping of extensions to loaders. If provided, the registry is copied to prevent external mutations.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>_registry</code> <code>dict[str, BaseLoader[Any]]</code> <p>Internal mapping of registered extensions to loaders</p> Example <p>Basic usage with JSON and text loaders:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json, LoaderRegistry, JsonLoader, TextLoader\n&gt;&gt;&gt; registry = LoaderRegistry({\"json\": JsonLoader(), \"txt\": TextLoader()})\n&gt;&gt;&gt; registry\nLoaderRegistry(\n  (json): JsonLoader()\n  (txt): TextLoader()\n)\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     save_json({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = registry.load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.LoaderRegistry.find_loader","title":"iden.io.LoaderRegistry.find_loader","text":"<pre><code>find_loader(extension: str) -&gt; BaseLoader[Any]\n</code></pre> <p>Find the appropriate loader for a given file extension.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>The file extension to find a loader for (e.g., \"json\", \"txt\")</p> required <p>Returns:</p> Type Description <code>BaseLoader[Any]</code> <p>The loader registered for the given file extension</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no loader is registered for the extension</p> Example <pre><code>&gt;&gt;&gt; from iden.io import LoaderRegistry, JsonLoader\n&gt;&gt;&gt; registry = LoaderRegistry()\n&gt;&gt;&gt; registry.register(\"json\", JsonLoader())\n&gt;&gt;&gt; loader = registry.find_loader(\"json\")\n&gt;&gt;&gt; loader\nJsonLoader()\n</code></pre>"},{"location":"refs/io/#iden.io.LoaderRegistry.has_loader","title":"iden.io.LoaderRegistry.has_loader","text":"<pre><code>has_loader(extension: str) -&gt; bool\n</code></pre> <p>Check if a loader is registered for the given extension.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>The file extension to check (e.g., \"json\", \"txt\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a loader is registered for this extension, False otherwise</p> Example <pre><code>&gt;&gt;&gt; from iden.io import LoaderRegistry, JsonLoader\n&gt;&gt;&gt; registry = LoaderRegistry()\n&gt;&gt;&gt; registry.register(\"json\", JsonLoader())\n&gt;&gt;&gt; registry.has_loader(\"json\")\nTrue\n&gt;&gt;&gt; registry.has_loader(\"txt\")\nFalse\n</code></pre>"},{"location":"refs/io/#iden.io.LoaderRegistry.register","title":"iden.io.LoaderRegistry.register","text":"<pre><code>register(\n    extension: str,\n    loader: BaseLoader[Any],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register a loader for a given file extension.</p> <p>This method associates a loader instance with a specific file extension. When loading files with this extension, the registered loader will be used.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>The file extension to register (e.g., \"json\", \"txt\")</p> required <code>loader</code> <code>BaseLoader[Any]</code> <p>The loader instance that handles files with this extension</p> required <code>exist_ok</code> <code>bool</code> <p>If False (default), raises an error if the extension is already registered. If True, overwrites the existing registration silently.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the extension is already registered and exist_ok is False</p> Example <pre><code>&gt;&gt;&gt; from iden.io import LoaderRegistry, JsonLoader\n&gt;&gt;&gt; registry = LoaderRegistry()\n&gt;&gt;&gt; registry.register(\"json\", JsonLoader())\n&gt;&gt;&gt; registry\nLoaderRegistry(\n  (json): JsonLoader()\n)\n</code></pre>"},{"location":"refs/io/#iden.io.LoaderRegistry.register_many","title":"iden.io.LoaderRegistry.register_many","text":"<pre><code>register_many(\n    mapping: Mapping[str, BaseLoader[Any]],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register multiple loaders at once.</p> <p>This is a convenience method for bulk registration that internally calls register() for each extension-loader pair.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[str, BaseLoader[Any]]</code> <p>Dictionary mapping file extensions to loader instances</p> required <code>exist_ok</code> <code>bool</code> <p>If False (default), raises an error if any extension is already registered. If True, overwrites existing registrations silently.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If any extension is already registered and exist_ok is False</p> Example <pre><code>&gt;&gt;&gt; from iden.io import LoaderRegistry, JsonLoader, TextLoader\n&gt;&gt;&gt; registry = LoaderRegistry()\n&gt;&gt;&gt; registry.register_many({\"json\": JsonLoader(), \"txt\": TextLoader()})\n&gt;&gt;&gt; registry\nLoaderRegistry(\n  (json): JsonLoader()\n  (txt): TextLoader()\n)\n</code></pre>"},{"location":"refs/io/#iden.io.PickleLoader","title":"iden.io.PickleLoader","text":"<p>               Bases: <code>BaseLoader[T]</code></p> <p>Implement a data loader to load data in a pickle file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_pickle, PickleLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pkl\")\n...     save_pickle({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = PickleLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.PickleSaver","title":"iden.io.PickleSaver","text":"<p>               Bases: <code>BaseFileSaver[T]</code></p> <p>Implement a file saver to save data with a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>pickle.dump</code>.</p> <code>{}</code> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import PickleSaver, PickleLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pkl\")\n...     PickleSaver().save({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = PickleLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.TextLoader","title":"iden.io.TextLoader","text":"<p>               Bases: <code>BaseLoader[str]</code></p> <p>Implement a data loader to load data in a text file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_text, TextLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.txt\")\n...     save_text(\"hello\", path)\n...     data = TextLoader().load(path)\n...     data\n...\n'hello'\n</code></pre>"},{"location":"refs/io/#iden.io.TextSaver","title":"iden.io.TextSaver","text":"<p>               Bases: <code>BaseFileSaver[str]</code></p> <p>Implement a file saver to save data with a text file.</p> Note <p>If the data to save is not a string, it is converted to     a string before to be saved by using <code>str</code>.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import TextSaver, TextLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.txt\")\n...     TextSaver().save(\"hello\", path)\n...     data = TextLoader().load(path)\n...     data\n...\n'hello'\n</code></pre>"},{"location":"refs/io/#iden.io.TorchLoader","title":"iden.io.TorchLoader","text":"<p>               Bases: <code>BaseLoader[T]</code></p> <p>Implement a data loader to load data in a PyTorch file.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>torch.load</code>.</p> <code>{}</code> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_torch, TorchLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pt\")\n...     save_torch({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = TorchLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.TorchSaver","title":"iden.io.TorchSaver","text":"<p>               Bases: <code>BaseFileSaver[T]</code></p> <p>Implement a file saver to save data with a PyTorch file.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>torch.save</code>.</p> <code>{}</code> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import TorchSaver, TorchLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pt\")\n...     TorchSaver().save({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = TorchLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.YamlLoader","title":"iden.io.YamlLoader","text":"<p>               Bases: <code>BaseLoader[T]</code></p> <p>Implement a data loader to load data in a YAML file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_yaml, YamlLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.yaml\")\n...     save_yaml({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = YamlLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.YamlSaver","title":"iden.io.YamlSaver","text":"<p>               Bases: <code>BaseFileSaver[T]</code></p> <p>Implement a file saver to save data with a YAML file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import YamlSaver, YamlLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.yaml\")\n...     YamlSaver().save({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = YamlLoader().load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.get_default_loader_registry","title":"iden.io.get_default_loader_registry","text":"<pre><code>get_default_loader_registry() -&gt; LoaderRegistry\n</code></pre> <p>Get or create the default global registry.</p> <p>Returns:</p> Type Description <code>LoaderRegistry</code> <p>A LoaderRegistry instance with default loaders registered for</p> <code>LoaderRegistry</code> <p>common file formats (json, pkl, pickle, txt, yaml, yml, and</p> <code>LoaderRegistry</code> <p>optionally joblib and pt if their dependencies are available).</p> Notes <p>The singleton pattern means modifications to the returned registry affect all future calls to this function. An isolated registry can be created by instantiating a new LoaderRegistry directly.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json, get_default_loader_registry\n&gt;&gt;&gt; registry = get_default_loader_registry()\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     save_json({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = registry.load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.is_loader_config","title":"iden.io.is_loader_config","text":"<pre><code>is_loader_config(config: dict[Any, Any]) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseLoader</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[Any, Any]</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseLoader</code> object.</p> Example <pre><code>&gt;&gt;&gt; from iden.io import is_loader_config\n&gt;&gt;&gt; is_loader_config({\"_target_\": \"iden.io.JsonLoader\"})\nTrue\n</code></pre>"},{"location":"refs/io/#iden.io.is_saver_config","title":"iden.io.is_saver_config","text":"<pre><code>is_saver_config(config: dict[Any, Any]) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseSaver</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[Any, Any]</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseSaver</code> object.</p> Example <pre><code>&gt;&gt;&gt; from iden.io import is_saver_config\n&gt;&gt;&gt; is_saver_config({\"_target_\": \"iden.io.JsonSaver\"})\nTrue\n</code></pre>"},{"location":"refs/io/#iden.io.load","title":"iden.io.load","text":"<pre><code>load(\n    path: Path, registry: LoaderRegistry | None = None\n) -&gt; Any\n</code></pre> <p>Load the data from the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path with the data to load.</p> required <code>registry</code> <code>LoaderRegistry | None</code> <p>Registry to load data. If <code>None</code>, uses the default global registry.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The data</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json, load\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     save_json({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.load_cloudpickle","title":"iden.io.load_cloudpickle","text":"<pre><code>load_cloudpickle(path: Path) -&gt; Any\n</code></pre> <p>Load the data from a given pickle file with cloudpickle.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the pickle file.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data from the pickle file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_cloudpickle, load_cloudpickle\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pkl\")\n...     save_cloudpickle({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_cloudpickle(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.load_joblib","title":"iden.io.load_joblib","text":"<pre><code>load_joblib(path: Path) -&gt; Any\n</code></pre> <p>Load the data from a given pickle file with joblib.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the pickle file.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data from the pickle file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_joblib, load_joblib\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.joblib\")\n...     save_joblib({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_joblib(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.load_json","title":"iden.io.load_json","text":"<pre><code>load_json(path: Path) -&gt; Any\n</code></pre> <p>Load the data from a given JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data from the JSON file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json, load_json\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     save_json({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_json(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.load_pickle","title":"iden.io.load_pickle","text":"<pre><code>load_pickle(path: Path) -&gt; Any\n</code></pre> <p>Load the data from a given pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the pickle file.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data from the pickle file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_pickle, load_pickle\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pkl\")\n...     save_pickle({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_pickle(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.load_text","title":"iden.io.load_text","text":"<pre><code>load_text(path: Path) -&gt; str\n</code></pre> <p>Load the data from a given text file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path where to the text file.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The data from the text file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_text, load_text\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.txt\")\n...     save_text(\"hello\", path)\n...     data = load_text(path)\n...     data\n...\n'hello'\n</code></pre>"},{"location":"refs/io/#iden.io.load_torch","title":"iden.io.load_torch","text":"<pre><code>load_torch(path: Path, **kwargs: Any) -&gt; Any\n</code></pre> <p>Load the data from a given PyTorch file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the PyTorch file.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>torch.load</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The data from the PyTorch file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_torch, load_torch\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pt\")\n...     save_torch({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_torch(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.load_yaml","title":"iden.io.load_yaml","text":"<pre><code>load_yaml(path: Path) -&gt; Any\n</code></pre> <p>Load the data from a given YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data from the YAML file.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import load_yaml, save_yaml\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.yaml\")\n...     save_yaml({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_yaml(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.register_loaders","title":"iden.io.register_loaders","text":"<pre><code>register_loaders(\n    mapping: Mapping[str, BaseLoader[Any]],\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Register custom loaders to the default global registry.</p> <p>This allows users to add support for custom file extensions without modifying global state directly.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[str, BaseLoader[Any]]</code> <p>Dictionary mapping file extensions to loader instances</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, raises error if any extension is already registered. Defaults to <code>False</code>.</p> <code>False</code> Example <pre><code>&gt;&gt;&gt; from iden.io import register_loaders, TextLoader\n&gt;&gt;&gt; register_loaders({\"longtext\": TextLoader()})\n</code></pre>"},{"location":"refs/io/#iden.io.save_cloudpickle","title":"iden.io.save_cloudpickle","text":"<pre><code>save_cloudpickle(\n    to_save: Any,\n    path: Path,\n    *,\n    exist_ok: bool = False,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Save the given data in a pickle file with cloudpickle.</p> <p>Parameters:</p> Name Type Description Default <code>to_save</code> <code>Any</code> <p>The data to write in a pickle file.</p> required <code>path</code> <code>Path</code> <p>The path where to write the pickle file.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>exist_ok</code> is <code>False</code> (the default), <code>FileExistsError</code> is raised if the target file already exists. If <code>exist_ok</code> is <code>True</code>, <code>FileExistsError</code> will not be raised unless the given path already exists in the file system and is not a file.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>cloudpickle.dump</code>.</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>if the file already exists.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_cloudpickle, load_cloudpickle\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pkl\")\n...     save_cloudpickle({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_cloudpickle(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.save_joblib","title":"iden.io.save_joblib","text":"<pre><code>save_joblib(\n    to_save: Any,\n    path: Path,\n    *,\n    exist_ok: bool = False,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Save the given data in a pickle file with joblib.</p> <p>Parameters:</p> Name Type Description Default <code>to_save</code> <code>Any</code> <p>The data to write in a pickle file.</p> required <code>path</code> <code>Path</code> <p>The path where to write the pickle file.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>exist_ok</code> is <code>False</code> (the default), <code>FileExistsError</code> is raised if the target file already exists. If <code>exist_ok</code> is <code>True</code>, <code>FileExistsError</code> will not be raised unless the given path already exists in the file system and is not a file.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>joblib.dump</code>.</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>if the file already exists.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_joblib, load_joblib\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.joblib\")\n...     save_joblib({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_joblib(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.save_json","title":"iden.io.save_json","text":"<pre><code>save_json(\n    to_save: Any, path: Path, *, exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Save the given data in a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>to_save</code> <code>Any</code> <p>The data to write in a JSON file.</p> required <code>path</code> <code>Path</code> <p>The path where to write the JSON file.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>exist_ok</code> is <code>False</code> (the default), <code>FileExistsError</code> is raised if the target file already exists. If <code>exist_ok</code> is <code>True</code>, <code>FileExistsError</code> will not be raised unless the given path already exists in the file system and is not a file.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>if the file already exists.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json, load_json\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     save_json({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_json(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.save_pickle","title":"iden.io.save_pickle","text":"<pre><code>save_pickle(\n    to_save: Any,\n    path: Path,\n    *,\n    exist_ok: bool = False,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Save the given data in a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>to_save</code> <code>Any</code> <p>The data to write in a pickle file.</p> required <code>path</code> <code>Path</code> <p>The path where to write the pickle file.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>exist_ok</code> is <code>False</code> (the default), <code>FileExistsError</code> is raised if the target file already exists. If <code>exist_ok</code> is <code>True</code>, <code>FileExistsError</code> will not be raised unless the given path already exists in the file system and is not a file.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>pickle.dump</code>.</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>if the file already exists.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_pickle, load_pickle\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pkl\")\n...     save_pickle({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_pickle(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.save_text","title":"iden.io.save_text","text":"<pre><code>save_text(\n    to_save: Any, path: Path, *, exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Save the given data in a text file.</p> <p>Parameters:</p> Name Type Description Default <code>to_save</code> <code>Any</code> <p>The data to write in a text file.</p> required <code>path</code> <code>Path</code> <p>The path where to write the text file.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>exist_ok</code> is <code>False</code> (the default), <code>FileExistsError</code> is raised if the target file already exists. If <code>exist_ok</code> is <code>True</code>, <code>FileExistsError</code> will not be raised unless the given path already exists in the file system and is not a file.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>if the file already exists.</p> Note <p>If the data to save is not a string, it is converted to     a string before to be saved by using <code>str</code>.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_text, load_text\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.txt\")\n...     save_text(\"hello\", path)\n...     data = load_text(path)\n...     data\n...\n'hello'\n</code></pre>"},{"location":"refs/io/#iden.io.save_torch","title":"iden.io.save_torch","text":"<pre><code>save_torch(\n    to_save: Any,\n    path: Path,\n    *,\n    exist_ok: bool = False,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Save the given data in a PyTorch file.</p> <p>Parameters:</p> Name Type Description Default <code>to_save</code> <code>Any</code> <p>The data to write in a PyTorch file.</p> required <code>path</code> <code>Path</code> <p>The path where to write the PyTorch file.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>exist_ok</code> is <code>False</code> (the default), <code>FileExistsError</code> is raised if the target file already exists. If <code>exist_ok</code> is <code>True</code>, <code>FileExistsError</code> will not be raised unless the given path already exists in the file system and is not a file.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>torch.save</code>.</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>if the file already exists.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_torch, load_torch\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.pt\")\n...     save_torch({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_torch(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.save_yaml","title":"iden.io.save_yaml","text":"<pre><code>save_yaml(\n    to_save: Any, path: Path, *, exist_ok: bool = False\n) -&gt; None\n</code></pre> <p>Save the given data in a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>to_save</code> <code>Any</code> <p>The data to write in a YAML file.</p> required <code>path</code> <code>Path</code> <p>The path where to write the YAML file.</p> required <code>exist_ok</code> <code>bool</code> <p>If <code>exist_ok</code> is <code>False</code> (the default), <code>FileExistsError</code> is raised if the target file already exists. If <code>exist_ok</code> is <code>True</code>, <code>FileExistsError</code> will not be raised unless the given path already exists in the file system and is not a file.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>if the file already exists.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import load_yaml, save_yaml\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.yaml\")\n...     save_yaml({\"key1\": [1, 2, 3], \"key2\": \"abc\"}, path)\n...     data = load_yaml(path)\n...     data\n...\n{'key1': [1, 2, 3], 'key2': 'abc'}\n</code></pre>"},{"location":"refs/io/#iden.io.setup_loader","title":"iden.io.setup_loader","text":"<pre><code>setup_loader(\n    loader: BaseLoader[T] | dict[Any, Any],\n) -&gt; BaseLoader[T]\n</code></pre> <p>Set up a data loader.</p> <p>The data loader is instantiated from its configuration by using the <code>BaseLoader</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>BaseLoader[T] | dict[Any, Any]</code> <p>The data loader or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseLoader[T]</code> <p>The instantiated data loader.</p> Example <pre><code>&gt;&gt;&gt; from iden.io import setup_loader\n&gt;&gt;&gt; loader = setup_loader({\"_target_\": \"iden.io.JsonLoader\"})\n&gt;&gt;&gt; loader\nJsonLoader()\n</code></pre>"},{"location":"refs/io/#iden.io.setup_saver","title":"iden.io.setup_saver","text":"<pre><code>setup_saver(\n    saver: BaseSaver[T] | dict[Any, Any],\n) -&gt; BaseSaver[T]\n</code></pre> <p>Set up a data saver.</p> <p>The data saver is instantiated from its configuration by using the <code>BaseSaver</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>saver</code> <code>BaseSaver[T] | dict[Any, Any]</code> <p>The data saver or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseSaver[T]</code> <p>The instantiated data saver.</p> Example <pre><code>&gt;&gt;&gt; from iden.io import setup_saver\n&gt;&gt;&gt; saver = setup_saver({\"_target_\": \"iden.io.JsonSaver\"})\n&gt;&gt;&gt; saver\nJsonSaver()\n</code></pre>"},{"location":"refs/io/#iden.io.safetensors","title":"iden.io.safetensors","text":"<p>Contain safetensors data loaders and savers.</p>"},{"location":"refs/io/#iden.io.safetensors.NumpyLoader","title":"iden.io.safetensors.NumpyLoader","text":"<p>               Bases: <code>BaseLoader[dict[str, ndarray]]</code></p> <p>Implement a file loader to load <code>numpy.ndarray</code>s in the safetensors format.</p> <p>Link: https://huggingface.co/docs/safetensors/en/index</p>"},{"location":"refs/io/#iden.io.safetensors.NumpySafetensorsLoader","title":"iden.io.safetensors.NumpySafetensorsLoader","text":"<p>               Bases: <code>BaseLoader[dict[str, ndarray]]</code></p> <p>Implement a file loader to load <code>numpy.ndarray</code>s in the safetensors format.</p> <p>Link: https://huggingface.co/docs/safetensors/en/index</p>"},{"location":"refs/io/#iden.io.safetensors.NumpySafetensorsSaver","title":"iden.io.safetensors.NumpySafetensorsSaver","text":"<p>               Bases: <code>BaseFileSaver[dict[str, ndarray]]</code></p> <p>Implement a file saver to save <code>numpy.ndarray</code>s with the safetensors format.</p> <p>This saver can only save a dictionary of <code>numpy.ndarray</code>s.</p> <p>Link: https://huggingface.co/docs/safetensors/en/index</p>"},{"location":"refs/io/#iden.io.safetensors.NumpySaver","title":"iden.io.safetensors.NumpySaver","text":"<p>               Bases: <code>BaseFileSaver[dict[str, ndarray]]</code></p> <p>Implement a file saver to save <code>numpy.ndarray</code>s with the safetensors format.</p> <p>This saver can only save a dictionary of <code>numpy.ndarray</code>s.</p> <p>Link: https://huggingface.co/docs/safetensors/en/index</p>"},{"location":"refs/io/#iden.io.safetensors.TorchLoader","title":"iden.io.safetensors.TorchLoader","text":"<p>               Bases: <code>BaseLoader[dict[str, Tensor]]</code></p> <p>Implement a file loader to load <code>torch.Tensor</code>s in the safetensors format.</p> <p>Link: https://huggingface.co/docs/safetensors/en/index</p>"},{"location":"refs/io/#iden.io.safetensors.TorchSafetensorsLoader","title":"iden.io.safetensors.TorchSafetensorsLoader","text":"<p>               Bases: <code>BaseLoader[dict[str, Tensor]]</code></p> <p>Implement a file loader to load <code>torch.Tensor</code>s in the safetensors format.</p> <p>Link: https://huggingface.co/docs/safetensors/en/index</p>"},{"location":"refs/io/#iden.io.safetensors.TorchSafetensorsSaver","title":"iden.io.safetensors.TorchSafetensorsSaver","text":"<p>               Bases: <code>BaseFileSaver[dict[str, Tensor]]</code></p> <p>Implement a file saver to save <code>torch.Tensor</code>s with the safetensors format.</p> <p>This saver can only save a dictionary of <code>torch.Tensor</code>s.</p> <p>Link: https://huggingface.co/docs/safetensors/en/index</p>"},{"location":"refs/io/#iden.io.safetensors.TorchSaver","title":"iden.io.safetensors.TorchSaver","text":"<p>               Bases: <code>BaseFileSaver[dict[str, Tensor]]</code></p> <p>Implement a file saver to save <code>torch.Tensor</code>s with the safetensors format.</p> <p>This saver can only save a dictionary of <code>torch.Tensor</code>s.</p> <p>Link: https://huggingface.co/docs/safetensors/en/index</p>"},{"location":"refs/shard/","title":"iden.shard","text":""},{"location":"refs/shard/#iden.shard","title":"iden.shard","text":"<p>Contain shard implementations.</p>"},{"location":"refs/shard/#iden.shard.BaseShard","title":"iden.shard.BaseShard","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a shard.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json\n&gt;&gt;&gt; from iden.shard import JsonShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"uri/0001\").as_uri()\n...     file = Path(tmpdir).joinpath(\"data.json\")\n...     save_json([1, 2, 3], file)\n...     shard = JsonShard(uri=uri, path=file)\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.BaseShard.clear","title":"iden.shard.BaseShard.clear  <code>abstractmethod</code>","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear the current shard cache i.e. remove from memory the data if possible.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json\n&gt;&gt;&gt; from iden.shard import JsonShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"uri/0001\").as_uri()\n...     file = Path(tmpdir).joinpath(\"data.json\")\n...     save_json([1, 2, 3], file)\n...     shard = JsonShard(uri=uri, path=file)\n...     data = shard.get_data(cache=True)\n...     data\n...     data.append(4)  # in-place modification\n...     data = shard.get_data()\n...     data\n...     shard.clear()\n...     data = shard.get_data()\n...     data\n...\n[1, 2, 3]\n[1, 2, 3, 4]\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.BaseShard.equal","title":"iden.shard.BaseShard.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two shards are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare with.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two shards are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import JsonShard, create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri1 = Path(tmpdir).joinpath(\"my_uri1\").as_uri()\n...     uri2 = Path(tmpdir).joinpath(\"my_uri2\").as_uri()\n...     shard1 = create_json_shard([1, 2, 3], uri=uri1)\n...     shard2 = create_json_shard([4, 5, 6], uri=uri2)\n...     shard3 = JsonShard.from_uri(uri=uri1)\n...     shard1.equal(shard2)\n...     shard1.equal(shard3)\n...\nFalse\nTrue\n</code></pre>"},{"location":"refs/shard/#iden.shard.BaseShard.get_data","title":"iden.shard.BaseShard.get_data  <code>abstractmethod</code>","text":"<pre><code>get_data(cache: bool = False) -&gt; T\n</code></pre> <p>Get the data in the shard.</p> <p>Parameters:</p> Name Type Description Default <code>cache</code> <code>bool</code> <p>If <code>True</code>, the shard will cache the data when the data are loaded the first time.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The data in the shard.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json\n&gt;&gt;&gt; from iden.shard import JsonShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"uri/0001\").as_uri()\n...     file = Path(tmpdir).joinpath(\"data.json\")\n...     save_json([1, 2, 3], file)\n...     shard = JsonShard(uri=uri, path=file)\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.BaseShard.get_uri","title":"iden.shard.BaseShard.get_uri  <code>abstractmethod</code>","text":"<pre><code>get_uri() -&gt; str | None\n</code></pre> <p>Get the Uniform Resource Identifier (URI) of the shard.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The Uniform Resource Identifier (URI).</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json\n&gt;&gt;&gt; from iden.shard import JsonShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"uri/0001\").as_uri()\n...     file = Path(tmpdir).joinpath(\"data.json\")\n...     save_json([1, 2, 3], file)\n...     shard = JsonShard(uri=uri, path=file)\n...     shard.get_uri()\n...\n'file:///.../uri/0001'\n</code></pre>"},{"location":"refs/shard/#iden.shard.BaseShard.is_cached","title":"iden.shard.BaseShard.is_cached  <code>abstractmethod</code>","text":"<pre><code>is_cached() -&gt; bool\n</code></pre> <p>Indicate if the data in the shard are cached or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the data are cached, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.io import save_json\n&gt;&gt;&gt; from iden.shard import JsonShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"uri/0001\").as_uri()\n...     file = Path(tmpdir).joinpath(\"data.json\")\n...     save_json([1, 2, 3], file)\n...     shard = JsonShard(uri=uri, path=file)\n...     shard.is_cached()\n...     data = shard.get_data(cache=True)\n...     shard.is_cached()\n...     shard.clear()\n...     shard.is_cached()\n...\nFalse\nTrue\nFalse\n</code></pre>"},{"location":"refs/shard/#iden.shard.CloudpickleShard","title":"iden.shard.CloudpickleShard","text":"<p>               Bases: <code>FileShard[T]</code></p> <p>Implement a cloudpickle shard for advanced Python object serialization.</p> <p>This shard stores data using cloudpickle, which extends Python's pickle to handle more complex objects like lambda functions and nested classes. The data are stored in a cloudpickle file.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | str</code> <p>The path to the cloudpickle file.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>cloudpickle</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import CloudpickleShard\n&gt;&gt;&gt; from iden.io import save_pickle\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.pkl\")\n...     save_pickle([1, 2, 3], file)\n...     shard = CloudpickleShard(uri=\"file:///data/1234456789\", path=file)\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.CloudpickleShard.generate_uri_config","title":"iden.shard.CloudpickleShard.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(path: Path) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the shard from its URI.</p> <p>The config must be compatible with the JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the pickle file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import CloudpickleShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.pkl\")\n...     CloudpickleShard.generate_uri_config(file)\n...\n{'kwargs': {'path': '.../data.pkl'},\n 'loader': {'_target_': 'iden.shard.loader.CloudpickleShardLoader'}}\n</code></pre>"},{"location":"refs/shard/#iden.shard.FileShard","title":"iden.shard.FileShard","text":"<p>               Bases: <code>BaseShard[T]</code></p> <p>Implement a generic shard where the data are stored in a single file.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | str</code> <p>The path to the pickle file.</p> required <code>loader</code> <code>BaseLoader[T] | dict[Any, Any] | None</code> <p>The data loader or its configuration.</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import FileShard\n&gt;&gt;&gt; from iden.io import save_json, JsonLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.json\")\n...     save_json([1, 2, 3], file)\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     shard = FileShard(uri=uri, path=file, loader=JsonLoader())\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.FileShard.path","title":"iden.shard.FileShard.path  <code>property</code>","text":"<pre><code>path: Path\n</code></pre> <p>The path to the file with data.</p>"},{"location":"refs/shard/#iden.shard.FileShard.from_uri","title":"iden.shard.FileShard.from_uri  <code>classmethod</code>","text":"<pre><code>from_uri(uri: str) -&gt; S\n</code></pre> <p>Instantiate a shard from its URI.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The Uniform Resource Identifier (URI) of the file shard to load.</p> required <p>Returns:</p> Type Description <code>S</code> <p>The instantiated shard.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import FileShard, create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_json_shard([1, 2, 3], uri=uri)\n...     shard = FileShard.from_uri(uri)\n...     shard\n...\nJsonShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.FileShard.generate_uri_config","title":"iden.shard.FileShard.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(path: Path) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the shard from its URI.</p> <p>The config must be compatible with the JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the json file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import FileShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.json\")\n...     FileShard.generate_uri_config(file)\n...\n{'kwargs': {'path': '.../data.json'},\n 'loader': {'_target_': 'iden.shard.loader.FileShardLoader'}}\n</code></pre>"},{"location":"refs/shard/#iden.shard.InMemoryShard","title":"iden.shard.InMemoryShard","text":"<p>               Bases: <code>BaseShard[T]</code></p> <p>Implement an in-memory shard for transient data storage.</p> <p>This shard stores data directly in memory without persistence to disk. It does not have a valid URI as the data exists only during runtime.</p> Example <pre><code>&gt;&gt;&gt; from iden.shard import InMemoryShard\n&gt;&gt;&gt; shard = InMemoryShard([1, 2, 3])\n&gt;&gt;&gt; shard.get_data()\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.InMemoryShard.clear","title":"iden.shard.InMemoryShard.clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Do nothing because it is an in-memory shard.</p>"},{"location":"refs/shard/#iden.shard.JoblibShard","title":"iden.shard.JoblibShard","text":"<p>               Bases: <code>FileShard[T]</code></p> <p>Implement a joblib shard for efficient persistence of Python objects.</p> <p>This shard stores data in a joblib file format, which provides efficient serialization for numerical data and scikit-learn models. The data are stored in a joblib file.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | str</code> <p>The path to the joblib file.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>joblib</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import JoblibShard\n&gt;&gt;&gt; from iden.io import save_pickle\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.joblib\")\n...     save_pickle([1, 2, 3], file)\n...     shard = JoblibShard(uri=\"file:///data/1234456789\", path=file)\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.JoblibShard.generate_uri_config","title":"iden.shard.JoblibShard.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(path: Path) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the shard from its URI.</p> <p>The config must be compatible with the JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the pickle file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import JoblibShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.joblib\")\n...     JoblibShard.generate_uri_config(file)\n...\n{'kwargs': {'path': '.../data.joblib'},\n 'loader': {'_target_': 'iden.shard.loader.JoblibShardLoader'}}\n</code></pre>"},{"location":"refs/shard/#iden.shard.JsonShard","title":"iden.shard.JsonShard","text":"<p>               Bases: <code>FileShard[T]</code></p> <p>Implement a JSON shard for human-readable data persistence.</p> <p>This shard stores data in JSON (JavaScript Object Notation) format, providing a text-based, human-readable serialization. The data are stored in a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | str</code> <p>The path to the JSON file.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import JsonShard\n&gt;&gt;&gt; from iden.io import save_json\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.json\")\n...     save_json([1, 2, 3], file)\n...     shard = JsonShard(uri=\"file:///data/1234456789\", path=file)\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.JsonShard.generate_uri_config","title":"iden.shard.JsonShard.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(path: Path) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the shard from its URI.</p> <p>The config must be compatible with the JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the json file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import JsonShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.json\")\n...     JsonShard.generate_uri_config(file)\n...\n{'kwargs': {'path': '.../data.json'},\n 'loader': {'_target_': 'iden.shard.loader.JsonShardLoader'}}\n</code></pre>"},{"location":"refs/shard/#iden.shard.NumpySafetensorsShard","title":"iden.shard.NumpySafetensorsShard","text":"<p>               Bases: <code>FileShard[dict[str, ndarray]]</code></p> <p>Implement a safetensors shard for secure NumPy array storage.</p> <p>This shard stores NumPy arrays using the safetensors format, which provides fast and secure serialization without arbitrary code execution risks. The data are stored in a safetensors file.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | str</code> <p>The path to the safetensors file.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>safetensors</code> or <code>numpy</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import NumpySafetensorsShard\n&gt;&gt;&gt; from iden.io.safetensors import NumpySaver\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.safetensors\")\n...     NumpySaver().save({\"key1\": np.ones((2, 3)), \"key2\": np.arange(5)}, file)\n...     shard = NumpySafetensorsShard(uri=\"file:///data/1234456789\", path=file)\n...     dict(sorted(shard.get_data().items()))\n...\n{'key1': array([[1., 1., 1.], [1., 1., 1.]]), 'key2': array([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/shard/#iden.shard.NumpySafetensorsShard.generate_uri_config","title":"iden.shard.NumpySafetensorsShard.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(path: Path) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the shard from its URI.</p> <p>The config must be compatible with the JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the pickle file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import NumpySafetensorsShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.safetensors\")\n...     NumpySafetensorsShard.generate_uri_config(file)\n...\n{'kwargs': {'path': '.../data.safetensors'},\n 'loader': {'_target_': 'iden.shard.loader.NumpySafetensorsShardLoader'}}\n</code></pre>"},{"location":"refs/shard/#iden.shard.PickleShard","title":"iden.shard.PickleShard","text":"<p>               Bases: <code>FileShard[T]</code></p> <p>Implement a pickle shard for Python object serialization.</p> <p>This shard stores data using Python's pickle protocol, which allows serialization of arbitrary Python objects. The data are stored in a pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | str</code> <p>The path to the pickle file.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import PickleShard\n&gt;&gt;&gt; from iden.io import save_pickle\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.pkl\")\n...     save_pickle([1, 2, 3], file)\n...     shard = PickleShard(uri=\"file:///data/1234456789\", path=file)\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.PickleShard.generate_uri_config","title":"iden.shard.PickleShard.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(path: Path) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the shard from its URI.</p> <p>The config must be compatible with the JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the pickle file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import PickleShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.pkl\")\n...     PickleShard.generate_uri_config(file)\n...\n{'kwargs': {'path': '.../data.pkl'},\n 'loader': {'_target_': 'iden.shard.loader.PickleShardLoader'}}\n</code></pre>"},{"location":"refs/shard/#iden.shard.ShardDict","title":"iden.shard.ShardDict","text":"<p>               Bases: <code>BaseShard[T]</code></p> <p>Implement a data structure to manage a dictionary of shards.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>shards</code> <code>dict[str, BaseShard[T]]</code> <p>The dictionary of shards.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import VanillaDataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, ShardDict\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = {\n...         \"train\": create_json_shard(\n...             [1, 2, 3], uri=Path(tmpdir).joinpath(\"shards/uri1\").as_uri()\n...         ),\n...         \"val\": create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shards/uri2\").as_uri()\n...         ),\n...     }\n...     sd = ShardDict(uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards)\n...     sd\n...\nShardDict(\n  (uri): file:///.../uri\n  (shards):\n    (train): JsonShard(uri=file:///.../shards/uri1)\n    (val): JsonShard(uri=file:///.../shards/uri2)\n)\n</code></pre>"},{"location":"refs/shard/#iden.shard.ShardDict.from_uri","title":"iden.shard.ShardDict.from_uri  <code>classmethod</code>","text":"<pre><code>from_uri(uri: str) -&gt; ShardDict[T]\n</code></pre> <p>Instantiate a shard from its URI.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The Uniform Resource Identifier (URI) of the shard dictionary to load.</p> required <p>Returns:</p> Type Description <code>ShardDict[T]</code> <p>The instantiated shard.</p> <p>Example: <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import ShardDict, create_json_shard, create_shard_dict\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = {\n...         \"train\": create_json_shard(\n...             [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...         ),\n...         \"val\": create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     }\n...     uri = Path(tmpdir).joinpath(\"uri\").as_uri()\n...     create_shard_dict(shards, uri=uri)\n...     shard = ShardDict.from_uri(uri)\n...     shard\n...\nShardDict(\n  (uri): file:///.../uri\n  (shards):\n    (train): JsonShard(uri=file:///.../shard/uri1)\n    (val): JsonShard(uri=file:///.../shard/uri2)\n)\n</code></pre></p>"},{"location":"refs/shard/#iden.shard.ShardDict.generate_uri_config","title":"iden.shard.ShardDict.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(\n    shards: dict[str, BaseShard[T]],\n) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the shard from its URI.</p> <p>The config must be compatible with the JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>shards</code> <code>dict[str, BaseShard[T]]</code> <p>The dictionary of shards to include in the configuration, where keys are shard identifiers.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> <p>Example: <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import ShardDict, create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = {\n...         \"train\": create_json_shard(\n...             [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...         ),\n...         \"val\": create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     }\n...     ShardDict.generate_uri_config(shards)\n...\n{'shards': {'train': 'file:///.../shard/uri1', 'val': 'file:///.../shard/uri2'},\n 'loader': {'_target_': 'iden.shard.loader.ShardDictLoader'}}\n</code></pre></p>"},{"location":"refs/shard/#iden.shard.ShardDict.get_shard","title":"iden.shard.ShardDict.get_shard","text":"<pre><code>get_shard(shard_id: str) -&gt; Any\n</code></pre> <p>Get a shard.</p> <p>Parameters:</p> Name Type Description Default <code>shard_id</code> <code>str</code> <p>The shard ID.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The shard.</p> <p>Raises:</p> Type Description <code>ShardNotFoundError</code> <p>if the shard does not exist.</p> <p>Example: <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard, ShardDict\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = {\n...         \"train\": create_json_shard(\n...             [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...         ),\n...         \"val\": create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     }\n...     sd = ShardDict(uri=Path(tmpdir).joinpath(\"main_uri\").as_uri(), shards=shards)\n...     sd.get_shard(\"train\")\n...\nJsonShard(uri=file:///.../uri1)\n</code></pre></p>"},{"location":"refs/shard/#iden.shard.ShardDict.get_shard_ids","title":"iden.shard.ShardDict.get_shard_ids","text":"<pre><code>get_shard_ids() -&gt; set[str]\n</code></pre> <p>Get the shard IDs.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>The shard IDs.</p> <p>Example: <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard, ShardDict\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = {\n...         \"train\": create_json_shard(\n...             [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...         ),\n...         \"val\": create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     }\n...     sd = ShardDict(uri=Path(tmpdir).joinpath(\"main_uri\").as_uri(), shards=shards)\n...     sorted(sd.get_shard_ids())\n...\n['train', 'val']\n</code></pre></p>"},{"location":"refs/shard/#iden.shard.ShardDict.has_shard","title":"iden.shard.ShardDict.has_shard","text":"<pre><code>has_shard(shard_id: str) -&gt; bool\n</code></pre> <p>Indicate if the shard exists or not.</p> <p>Parameters:</p> Name Type Description Default <code>shard_id</code> <code>str</code> <p>The shard ID.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the shard exists, otherwise <code>False</code></p> <p>Example: <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard, ShardDict\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = {\n...         \"train\": create_json_shard(\n...             [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...         ),\n...         \"val\": create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     }\n...     sd = ShardDict(uri=Path(tmpdir).joinpath(\"main_uri\").as_uri(), shards=shards)\n...     sd.has_shard(\"train\")\n...     sd.has_shard(\"test\")\n...\nTrue\nFalse\n</code></pre></p>"},{"location":"refs/shard/#iden.shard.ShardTuple","title":"iden.shard.ShardTuple","text":"<p>               Bases: <code>BaseShard[tuple[BaseShard[T], ...]]</code></p> <p>Implement a data structure to manage a tuple of shards.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>shards</code> <code>Iterable[BaseShard[T]]</code> <p>The tuple of shards.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; from iden.shard import ShardTuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = [\n...         create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"shards/uri1\").as_uri()),\n...         create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shards/uri2\").as_uri()\n...         ),\n...     ]\n...     sl = ShardTuple(uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards)\n...     sl\n...\nShardTuple(\n  (uri): file:///.../uri\n  (shards):\n    (0): JsonShard(uri=file:///.../shards/uri1)\n    (1): JsonShard(uri=file:///.../shards/uri2)\n)\n</code></pre>"},{"location":"refs/shard/#iden.shard.ShardTuple.from_uri","title":"iden.shard.ShardTuple.from_uri  <code>classmethod</code>","text":"<pre><code>from_uri(uri: str) -&gt; ShardTuple[T]\n</code></pre> <p>Instantiate a shard from its URI.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The Uniform Resource Identifier (URI) of the shard tuple to load.</p> required <p>Returns:</p> Type Description <code>ShardTuple[T]</code> <p>The instantiated shard.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import ShardTuple, create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = [\n...         create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()),\n...         create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     ]\n...     uri = Path(tmpdir).joinpath(\"uri\").as_uri()\n...     create_shard_tuple(shards, uri=uri)\n...     shard = ShardTuple.from_uri(uri)\n...     shard\n...\nShardTuple(\n  (uri): file:///.../uri\n  (shards):\n    (0): JsonShard(uri=file:///.../shard/uri1)\n    (1): JsonShard(uri=file:///.../shard/uri2)\n)\n</code></pre>"},{"location":"refs/shard/#iden.shard.ShardTuple.generate_uri_config","title":"iden.shard.ShardTuple.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(\n    shards: Iterable[BaseShard[T]],\n) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the shard from its URI.</p> <p>The config must be compatible with the JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>shards</code> <code>Iterable[BaseShard[T]]</code> <p>The sequence of shards to include in the configuration.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import ShardTuple, create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = [\n...         create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()),\n...         create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     ]\n...     ShardTuple.generate_uri_config(shards)\n...\n{'shards': ['file:///.../shard/uri1', 'file:///.../shard/uri2'],\n 'loader': {'_target_': 'iden.shard.loader.ShardTupleLoader'}}\n</code></pre>"},{"location":"refs/shard/#iden.shard.ShardTuple.get","title":"iden.shard.ShardTuple.get","text":"<pre><code>get(index: int) -&gt; BaseShard[T]\n</code></pre> <p>Get a shard.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The shard index to get.</p> required <p>Returns:</p> Type Description <code>BaseShard[T]</code> <p>The shard.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>if the index is outside the tuple range.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; from iden.shard import ShardTuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = [\n...         create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()),\n...         create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     ]\n...     sl = ShardTuple(uri=Path(tmpdir).joinpath(\"main_uri\").as_uri(), shards=shards)\n...     sl.get(0)\n...\nJsonShard(uri=file:///.../uri1)\n</code></pre>"},{"location":"refs/shard/#iden.shard.ShardTuple.is_sorted_by_uri","title":"iden.shard.ShardTuple.is_sorted_by_uri","text":"<pre><code>is_sorted_by_uri() -&gt; bool\n</code></pre> <p>Indicate if the shards are sorted by ascending order of URIs or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the shards are sorted by ascending order of URIs, otherwise <code>False</code>.</p>"},{"location":"refs/shard/#iden.shard.TorchSafetensorsShard","title":"iden.shard.TorchSafetensorsShard","text":"<p>               Bases: <code>FileShard[dict[str, Tensor]]</code></p> <p>Implement a safetensors shard for secure PyTorch tensor storage.</p> <p>This shard stores PyTorch tensors using the safetensors format, which provides fast and secure serialization without arbitrary code execution risks. The data are stored in a safetensors file.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | str</code> <p>The path to the safetensors file.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>safetensors</code> or <code>torch</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import TorchSafetensorsShard\n&gt;&gt;&gt; from iden.io.safetensors import TorchSaver\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.safetensors\")\n...     TorchSaver().save({\"key1\": torch.ones(2, 3), \"key2\": torch.arange(5)}, file)\n...     shard = TorchSafetensorsShard(uri=\"file:///data/1234456789\", path=file)\n...     dict(sorted(shard.get_data().items()))\n...\n{'key1': tensor([[1., 1., 1.], [1., 1., 1.]]), 'key2': tensor([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/shard/#iden.shard.TorchSafetensorsShard.generate_uri_config","title":"iden.shard.TorchSafetensorsShard.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(path: Path) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the shard from its URI.</p> <p>The config must be compatible with the JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the pickle file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import TorchSafetensorsShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.safetensors\")\n...     TorchSafetensorsShard.generate_uri_config(file)\n...\n{'kwargs': {'path': '.../data.safetensors'},\n 'loader': {'_target_': 'iden.shard.loader.TorchSafetensorsShardLoader'}}\n</code></pre>"},{"location":"refs/shard/#iden.shard.TorchShard","title":"iden.shard.TorchShard","text":"<p>               Bases: <code>FileShard[T]</code></p> <p>Implement a PyTorch shard for efficient tensor storage.</p> <p>This shard stores data in PyTorch's native file format, optimized for <code>torch.Tensor</code> objects and PyTorch state dictionaries. The data are stored in a PyTorch file.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | str</code> <p>The path to the PyTorch file.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>torch</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import TorchShard\n&gt;&gt;&gt; from iden.io import TorchSaver\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.pt\")\n...     TorchSaver().save({\"key1\": torch.ones(2, 3), \"key2\": torch.arange(5)}, file)\n...     shard = TorchShard(uri=\"file:///data/1234456789\", path=file)\n...     shard.get_data()\n...\n{'key1': tensor([[1., 1., 1.], [1., 1., 1.]]), 'key2': tensor([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/shard/#iden.shard.TorchShard.generate_uri_config","title":"iden.shard.TorchShard.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(path: Path) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the shard from its URI.</p> <p>The config must be compatible with the JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the pickle file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import TorchShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.pt\")\n...     TorchShard.generate_uri_config(file)\n...\n{'kwargs': {'path': '.../data.pt'},\n 'loader': {'_target_': 'iden.shard.loader.TorchShardLoader'}}\n</code></pre>"},{"location":"refs/shard/#iden.shard.YamlShard","title":"iden.shard.YamlShard","text":"<p>               Bases: <code>FileShard[T]</code></p> <p>Implement a YAML shard for human-readable configuration storage.</p> <p>This shard stores data in YAML (YAML Ain't Markup Language) format, which provides a readable text-based serialization commonly used for configuration files. The data are stored in a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | str</code> <p>The path to the YAML file.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import YamlShard\n&gt;&gt;&gt; from iden.io import save_yaml\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.yaml\")\n...     save_yaml([1, 2, 3], file)\n...     shard = YamlShard(uri=\"file:///data/1234456789\", path=file)\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.YamlShard.generate_uri_config","title":"iden.shard.YamlShard.generate_uri_config  <code>classmethod</code>","text":"<pre><code>generate_uri_config(path: Path) -&gt; dict[str, Any]\n</code></pre> <p>Generate the minimal config that is used to load the shard from its URI.</p> <p>The config must be compatible with the YAML format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the yaml file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The minimal config to load the shard from its URI.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import YamlShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     file = Path(tmpdir).joinpath(\"data.yaml\")\n...     YamlShard.generate_uri_config(file)\n...\n{'kwargs': {'path': '.../data.yaml'},\n 'loader': {'_target_': 'iden.shard.loader.YamlShardLoader'}}\n</code></pre>"},{"location":"refs/shard/#iden.shard.create_cloudpickle_shard","title":"iden.shard.create_cloudpickle_shard","text":"<pre><code>create_cloudpickle_shard(\n    data: T, uri: str, path: Path | None = None\n) -&gt; CloudpickleShard[T]\n</code></pre> <p>Create a <code>CloudpickleShard</code> from data.</p> Note <p>It is a utility function to create a <code>CloudpickleShard</code> from its     data and URI. It is possible to create a <code>CloudpickleShard</code>     in other ways.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data to save in the cloudpickle file.</p> required <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | None</code> <p>The path to the cloudpickle file. If <code>None</code>, a path is automatically based on the URI.</p> <code>None</code> <p>Returns:</p> Type Description <code>CloudpickleShard[T]</code> <p>The <code>CloudpickleShard</code> object.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>cloudpickle</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_pickle_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_pickle_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"my_uri\").as_uri())\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.create_joblib_shard","title":"iden.shard.create_joblib_shard","text":"<pre><code>create_joblib_shard(\n    data: T, uri: str, path: Path | None = None\n) -&gt; JoblibShard[T]\n</code></pre> <p>Create a <code>JoblibShard</code> from data.</p> Note <p>It is a utility function to create a <code>JoblibShard</code> from its     data and URI. It is possible to create a <code>JoblibShard</code>     in other ways.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data to save in the joblib file.</p> required <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | None</code> <p>The path to the joblib file. If <code>None</code>, a path is automatically based on the URI.</p> <code>None</code> <p>Returns:</p> Type Description <code>JoblibShard[T]</code> <p>The <code>JoblibShard</code> object.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>joblib</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_pickle_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_pickle_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"my_uri\").as_uri())\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.create_json_shard","title":"iden.shard.create_json_shard","text":"<pre><code>create_json_shard(\n    data: T, uri: str, path: Path | None = None\n) -&gt; JsonShard[T]\n</code></pre> <p>Create a <code>JsonShard</code> from data.</p> Note <p>It is a utility function to create a <code>JsonShard</code> from its     data and URI. It is possible to create a <code>JsonShard</code>     in other ways.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data to save in the json file.</p> required <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | None</code> <p>The path to the JSON file. If <code>None</code>, a path is automatically based on the URI.</p> <code>None</code> <p>Returns:</p> Type Description <code>JsonShard[T]</code> <p>The <code>JsonShard</code> object.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"my_uri\").as_uri())\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.create_numpy_safetensors_shard","title":"iden.shard.create_numpy_safetensors_shard","text":"<pre><code>create_numpy_safetensors_shard(\n    data: dict[str, ndarray],\n    uri: str,\n    path: Path | None = None,\n) -&gt; NumpySafetensorsShard\n</code></pre> <p>Create a <code>NumpySafetensorsShard</code> from data.</p> Note <p>It is a utility function to create a <code>NumpySafetensorsShard</code>     from its data and URI. It is possible to create a     <code>NumpySafetensorsShard</code> in other ways.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, ndarray]</code> <p>The data to save in the safetensors file.</p> required <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | None</code> <p>The path to the safetensors file. If <code>None</code>, a path is automatically based on the URI.</p> <code>None</code> <p>Returns:</p> Type Description <code>NumpySafetensorsShard</code> <p>The <code>NumpySafetensorsShard</code> object.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>safetensors</code> or <code>torch</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_numpy_safetensors_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_numpy_safetensors_shard(\n...         data={\"key1\": np.ones((2, 3)), \"key2\": np.arange(5)},\n...         uri=Path(tmpdir).joinpath(\"my_uri\").as_uri(),\n...     )\n...     dict(sorted(shard.get_data().items()))\n...\n{'key1': array([[1., 1., 1.], [1., 1., 1.]]), 'key2': array([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/shard/#iden.shard.create_pickle_shard","title":"iden.shard.create_pickle_shard","text":"<pre><code>create_pickle_shard(\n    data: T, uri: str, path: Path | None = None\n) -&gt; PickleShard[T]\n</code></pre> <p>Create a <code>PickleShard</code> from data.</p> Note <p>It is a utility function to create a <code>PickleShard</code> from its     data and URI. It is possible to create a <code>PickleShard</code>     in other ways.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data to save in the pickle file.</p> required <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | None</code> <p>The path to the pickle file. If <code>None</code>, a path is automatically based on the URI.</p> <code>None</code> <p>Returns:</p> Type Description <code>PickleShard[T]</code> <p>The <code>PickleShard</code> object.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_pickle_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_pickle_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"my_uri\").as_uri())\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.create_shard_dict","title":"iden.shard.create_shard_dict","text":"<pre><code>create_shard_dict(\n    shards: dict[str, BaseShard[T]], uri: str\n) -&gt; ShardDict[T]\n</code></pre> <p>Create a <code>ShardDict</code> from a dictionary of shards.</p> Note <p>It is a utility function to create a <code>ShardDict</code> from its     shards and URI. It is possible to create a <code>ShardDict</code>     in other ways.</p> <p>Parameters:</p> Name Type Description Default <code>shards</code> <code>dict[str, BaseShard[T]]</code> <p>The dictionary of shards to include, where keys are shard identifiers and values are shard objects.</p> required <code>uri</code> <code>str</code> <p>The Uniform Resource Identifier (URI) for the shard dictionary.</p> required <p>Returns:</p> Type Description <code>ShardDict[T]</code> <p>The <code>ShardDict</code> object.</p> <p>Example: <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import ShardDict, create_json_shard, create_shard_dict\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = {\n...         \"train\": create_json_shard(\n...             [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...         ),\n...         \"val\": create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     }\n...     shard = create_shard_dict(shards, uri=Path(tmpdir).joinpath(\"uri\").as_uri())\n...     shard\n...\nShardDict(\n  (uri): file:///.../uri\n  (shards):\n    (train): JsonShard(uri=file:///.../shard/uri1)\n    (val): JsonShard(uri=file:///.../shard/uri2)\n)\n</code></pre></p>"},{"location":"refs/shard/#iden.shard.create_shard_tuple","title":"iden.shard.create_shard_tuple","text":"<pre><code>create_shard_tuple(\n    shards: Iterable[BaseShard[T]], uri: str\n) -&gt; ShardTuple[T]\n</code></pre> <p>Create a <code>ShardTuple</code> from a sequence of shards.</p> Note <p>It is a utility function to create a <code>ShardTuple</code> from its     shards and URI. It is possible to create a <code>ShardTuple</code>     in other ways.</p> <p>Parameters:</p> Name Type Description Default <code>shards</code> <code>Iterable[BaseShard[T]]</code> <p>The sequence of shards to include in the tuple.</p> required <code>uri</code> <code>str</code> <p>The Uniform Resource Identifier (URI) for the shard tuple.</p> required <p>Returns:</p> Type Description <code>ShardTuple[T]</code> <p>The <code>ShardTuple</code> object.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import ShardTuple, create_json_shard, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = [\n...         create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()),\n...         create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     ]\n...     shard = create_shard_tuple(shards, uri=Path(tmpdir).joinpath(\"uri\").as_uri())\n...     shard\n...\nShardTuple(\n  (uri): file:///.../uri\n  (shards):\n    (0): JsonShard(uri=file:///.../shard/uri1)\n    (1): JsonShard(uri=file:///.../shard/uri2)\n)\n</code></pre>"},{"location":"refs/shard/#iden.shard.create_torch_safetensors_shard","title":"iden.shard.create_torch_safetensors_shard","text":"<pre><code>create_torch_safetensors_shard(\n    data: dict[str, Tensor],\n    uri: str,\n    path: Path | None = None,\n) -&gt; TorchSafetensorsShard\n</code></pre> <p>Create a <code>TorchSafetensorsShard</code> from data.</p> Note <p>It is a utility function to create a <code>TorchSafetensorsShard</code>     from its data and URI. It is possible to create a     <code>TorchSafetensorsShard</code> in other ways.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Tensor]</code> <p>The data to save in the safetensors file.</p> required <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | None</code> <p>The path to the safetensors file. If <code>None</code>, a path is automatically based on the URI.</p> <code>None</code> <p>Returns:</p> Type Description <code>TorchSafetensorsShard</code> <p>The <code>TorchSafetensorsShard</code> object.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>safetensors</code> or <code>torch</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_torch_safetensors_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_torch_safetensors_shard(\n...         data={\"key1\": torch.ones(2, 3), \"key2\": torch.arange(5)},\n...         uri=Path(tmpdir).joinpath(\"my_uri\").as_uri(),\n...     )\n...     dict(sorted(shard.get_data().items()))\n...\n{'key1': tensor([[1., 1., 1.], [1., 1., 1.]]), 'key2': tensor([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/shard/#iden.shard.create_torch_shard","title":"iden.shard.create_torch_shard","text":"<pre><code>create_torch_shard(\n    data: T, uri: str, path: Path | None = None\n) -&gt; TorchShard[T]\n</code></pre> <p>Create a <code>TorchShard</code> from data.</p> Note <p>It is a utility function to create a <code>TorchShard</code> from its     data and URI. It is possible to create a <code>TorchShard</code>     in other ways.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data to save in the PyTorch file.</p> required <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | None</code> <p>The path to the PyTorch file. If <code>None</code>, a path is automatically based on the URI.</p> <code>None</code> <p>Returns:</p> Type Description <code>TorchShard[T]</code> <p>The <code>TorchShard</code> object.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>torch</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from iden.shard import create_torch_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_torch_shard(\n...         data={\"key1\": torch.ones(2, 3), \"key2\": torch.arange(5)},\n...         uri=Path(tmpdir).joinpath(\"my_uri\").as_uri(),\n...     )\n...     shard.get_data()\n...\n{'key1': tensor([[1., 1., 1.], [1., 1., 1.]]), 'key2': tensor([0, 1, 2, 3, 4])}\n</code></pre>"},{"location":"refs/shard/#iden.shard.create_yaml_shard","title":"iden.shard.create_yaml_shard","text":"<pre><code>create_yaml_shard(\n    data: T, uri: str, path: Path | None = None\n) -&gt; YamlShard[T]\n</code></pre> <p>Create a <code>YamlShard</code> from data.</p> Note <p>It is a utility function to create a <code>YamlShard</code> from its     data and URI. It is possible to create a <code>YamlShard</code>     in other ways.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The data to save in the yaml file.</p> required <code>uri</code> <code>str</code> <p>The shard's URI.</p> required <code>path</code> <code>Path | None</code> <p>The path to the YAML file. If <code>None</code>, a path is automatically based on the URI.</p> <code>None</code> <p>Returns:</p> Type Description <code>YamlShard[T]</code> <p>The <code>YamlShard</code> object.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_yaml_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_yaml_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"my_uri\").as_uri())\n...     shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"refs/shard/#iden.shard.get_dict_uris","title":"iden.shard.get_dict_uris","text":"<pre><code>get_dict_uris(\n    shards: dict[str, BaseShard[Any]],\n) -&gt; dict[str, str]\n</code></pre> <p>Get the dictionary of shard URIs.</p> <p>Parameters:</p> Name Type Description Default <code>shards</code> <code>dict[str, BaseShard[Any]]</code> <p>The dictionary of shards.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>The dictionary of shard URIs.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard, get_dict_uris\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = {\n...         \"train\": create_json_shard(\n...             [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...         ),\n...         \"val\": create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     }\n...     get_dict_uris(shards)\n...\n{'train': 'file:///.../shard/uri1', 'val': 'file:///.../shard/uri2'}\n</code></pre>"},{"location":"refs/shard/#iden.shard.get_list_uris","title":"iden.shard.get_list_uris","text":"<pre><code>get_list_uris(\n    shards: Iterable[BaseShard[Any]],\n) -&gt; list[str]\n</code></pre> <p>Get the list of shard URIs.</p> <p>Parameters:</p> Name Type Description Default <code>shards</code> <code>Iterable[BaseShard[Any]]</code> <p>The iterable of shards from which to extract URIs.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>The list of shard URIs.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import get_list_uris, create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = [\n...         create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()),\n...         create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     ]\n...     get_list_uris(shards)\n...\n['file:///.../shard/uri1', 'file:///.../shard/uri2']\n</code></pre>"},{"location":"refs/shard/#iden.shard.load_from_uri","title":"iden.shard.load_from_uri","text":"<pre><code>load_from_uri(uri: str) -&gt; BaseShard[Any]\n</code></pre> <p>Load a shard from its Uniform Resource Identifier (URI).</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The URI of the shard.</p> required <p>Returns:</p> Type Description <code>BaseShard[Any]</code> <p>The shard associated to the URI.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the URI file does not exist.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard, load_from_uri\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_json_shard([1, 2, 3], uri=uri)\n...     shard = load_from_uri(uri)\n...     shard\n...\nJsonShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.sort_by_uri","title":"iden.shard.sort_by_uri","text":"<pre><code>sort_by_uri(\n    shards: Iterable[BaseShard[Any]],\n    /,\n    *,\n    reverse: bool = False,\n) -&gt; list[BaseShard[Any]]\n</code></pre> <p>Sort a sequence of shards by their URIs.</p> <p>Parameters:</p> Name Type Description Default <code>shards</code> <code>Iterable[BaseShard[Any]]</code> <p>The shards to sort.</p> required <code>reverse</code> <code>bool</code> <p>If set to <code>True</code>, then the list elements are sorted as if each comparison were reversed.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[BaseShard[Any]]</code> <p>The sorted shards.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard, sort_by_uri\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = sort_by_uri(\n...         [\n...             create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"uri2\").as_uri()),\n...             create_json_shard([4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"uri3\").as_uri()),\n...             create_json_shard([4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"uri1\").as_uri()),\n...         ]\n...     )\n...     shards\n...\n[JsonShard(uri=file:///.../uri1), JsonShard(uri=file:///.../uri2), JsonShard(uri=file:///.../uri3)]\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator","title":"iden.shard.generator","text":"<p>Contain shard generator implementations.</p>"},{"location":"refs/shard/#iden.shard.generator.BaseShardGenerator","title":"iden.shard.generator.BaseShardGenerator","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to create a shard.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import JsonShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = JsonShardGenerator(\n...         data=DataGenerator([1, 2, 3]),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nJsonShardGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (path_shard): PosixPath('/.../data')\n  (data): DataGenerator(copy=False)\n)\nJsonShard(uri=file:///.../uri/shard1)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.BaseShardGenerator.equal","title":"iden.shard.generator.BaseShardGenerator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare with.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import JsonShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator1 = JsonShardGenerator(\n...         data=DataGenerator([1, 2, 3]),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator2 = JsonShardGenerator(\n...         data=DataGenerator([1, 2, 3]),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator3 = JsonShardGenerator(\n...         data=DataGenerator([]),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator1.equal(generator2)\n...     generator1.equal(generator3)\n...\nTrue\nFalse\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.BaseShardGenerator.generate","title":"iden.shard.generator.BaseShardGenerator.generate  <code>abstractmethod</code>","text":"<pre><code>generate(shard_id: str) -&gt; BaseShard[T]\n</code></pre> <p>Generate a shard.</p> <p>Parameters:</p> Name Type Description Default <code>shard_id</code> <code>str</code> <p>The shard IDI.</p> required <p>Returns:</p> Type Description <code>BaseShard[T]</code> <p>The generated shard.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import JsonShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = JsonShardGenerator(\n...         data=DataGenerator([1, 2, 3]),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nJsonShard(uri=file:///.../uri/shard1)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.CloudpickleShardGenerator","title":"iden.shard.generator.CloudpickleShardGenerator","text":"<p>               Bases: <code>BaseFileShardGenerator[T]</code></p> <p>Implement a cloudpickle shard generator.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BaseDataGenerator[T] | dict[Any, Any]</code> <p>The data to save in the shard.</p> required <code>path_uri</code> <code>Path</code> <p>The path where to save the URI file.</p> required <code>path_shard</code> <code>Path</code> <p>The path where to save the shard data.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import CloudpickleShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = CloudpickleShardGenerator(\n...         data=DataGenerator([1, 2, 3]),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nCloudpickleShardGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (path_shard): PosixPath('/.../data')\n  (data): DataGenerator(copy=False)\n)\nCloudpickleShard(uri=file:///.../uri/shard1)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.JoblibShardGenerator","title":"iden.shard.generator.JoblibShardGenerator","text":"<p>               Bases: <code>BaseFileShardGenerator[T]</code></p> <p>Implement a joblib shard generator.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BaseDataGenerator[T] | dict[Any, Any]</code> <p>The data to save in the shard.</p> required <code>path_uri</code> <code>Path</code> <p>The path where to save the URI file.</p> required <code>path_shard</code> <code>Path</code> <p>The path where to save the shard data.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import JoblibShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = JoblibShardGenerator(\n...         data=DataGenerator([1, 2, 3]),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nJoblibShardGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (path_shard): PosixPath('/.../data')\n  (data): DataGenerator(copy=False)\n)\nJoblibShard(uri=file:///.../uri/shard1)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.JsonShardGenerator","title":"iden.shard.generator.JsonShardGenerator","text":"<p>               Bases: <code>BaseFileShardGenerator[T]</code></p> <p>Implement a JSON shard generator for creating shards with JSON persistence.</p> <p>This generator creates shards that store data in JSON format, providing human-readable serialization suitable for structured data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BaseDataGenerator[T] | dict[Any, Any]</code> <p>The data to save in the shard.</p> required <code>path_uri</code> <code>Path</code> <p>The path where to save the URI file.</p> required <code>path_shard</code> <code>Path</code> <p>The path where to save the shard data.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import JsonShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = JsonShardGenerator(\n...         data=DataGenerator([1, 2, 3]),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nJsonShardGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (path_shard): PosixPath('/.../data')\n  (data): DataGenerator(copy=False)\n)\nJsonShard(uri=file:///.../uri/shard1)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.NumpySafetensorsShardGenerator","title":"iden.shard.generator.NumpySafetensorsShardGenerator","text":"<p>               Bases: <code>BaseFileShardGenerator[dict[str, ndarray]]</code></p> <p>Implement a safetensors shard generator.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BaseDataGenerator[dict[str, ndarray]] | dict[Any, Any]</code> <p>The data to save in the shard.</p> required <code>path_uri</code> <code>Path</code> <p>The path where to save the URI file.</p> required <code>path_shard</code> <code>Path</code> <p>The path where to save the shard data.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import NumpySafetensorsShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = NumpySafetensorsShardGenerator(\n...         data=DataGenerator({\"key1\": np.ones((2, 3)), \"key2\": np.arange(5)}),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nNumpySafetensorsShardGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (path_shard): PosixPath('/.../data')\n  (data): DataGenerator(copy=False)\n)\nNumpySafetensorsShard(uri=file:///.../uri/shard1)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.PickleShardGenerator","title":"iden.shard.generator.PickleShardGenerator","text":"<p>               Bases: <code>BaseFileShardGenerator[T]</code></p> <p>Implement a pickle shard generator for creating shards with pickle persistence.</p> <p>This generator creates shards that store data using Python's pickle protocol, suitable for arbitrary Python objects.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BaseDataGenerator[T] | dict[Any, Any]</code> <p>The data to save in the shard.</p> required <code>path_uri</code> <code>Path</code> <p>The path where to save the URI file.</p> required <code>path_shard</code> <code>Path</code> <p>The path where to save the shard data.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import PickleShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = PickleShardGenerator(\n...         data=DataGenerator([1, 2, 3]),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nPickleShardGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (path_shard): PosixPath('/.../data')\n  (data): DataGenerator(copy=False)\n)\nPickleShard(uri=file:///.../uri/shard1)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.ShardDictGenerator","title":"iden.shard.generator.ShardDictGenerator","text":"<p>               Bases: <code>BaseShardGenerator[dict[str, BaseShard[T]]]</code></p> <p>Implement a shard dictionary generator for creating dictionaries of shards.</p> <p>This generator creates ShardDict instances containing multiple named shards, useful for organizing data splits or related datasets.</p> <p>Parameters:</p> Name Type Description Default <code>shards</code> <code>dict[str, BaseShardGenerator[T] | dict[Any, Any]]</code> <p>The shard generators or their configurations.</p> required <code>path_uri</code> <code>Path</code> <p>The path where to save the URI file.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import ShardDictGenerator, JsonShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = ShardDictGenerator(\n...         shards={\n...             \"train\": JsonShardGenerator(\n...                 data=DataGenerator([1, 2, 3]),\n...                 path_uri=Path(tmpdir).joinpath(\"uri\"),\n...                 path_shard=Path(tmpdir).joinpath(\"data\"),\n...             )\n...         },\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...     )\n...     generator\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nShardDictGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (shards):\n    (train): JsonShardGenerator(\n        (path_uri): PosixPath('/.../uri')\n        (path_shard): PosixPath('/.../data')\n        (data): DataGenerator(copy=False)\n      )\n)\nShardDict(\n  (uri): file:///.../uri/shard1\n  (shards):\n    (train): JsonShard(uri=file:///.../uri/train)\n)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.ShardTupleGenerator","title":"iden.shard.generator.ShardTupleGenerator","text":"<p>               Bases: <code>BaseShardGenerator[tuple[BaseShard[T], ...]]</code></p> <p>Implement a shard tuple generator for creating sequences of shards.</p> <p>This generator creates ShardTuple instances containing an ordered sequence of shards, useful for organizing sequential data batches.</p> <p>Parameters:</p> Name Type Description Default <code>shard</code> <code>BaseShardGenerator[T] | dict[Any, Any]</code> <p>The shard generator or its configuration.</p> required <code>num_shards</code> <code>int</code> <p>The number of shards to generate in the <code>ShardTuple</code>.</p> required <code>path_uri</code> <code>Path</code> <p>The path where to save the URI file.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import ShardTupleGenerator, JsonShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = ShardTupleGenerator(\n...         shard=JsonShardGenerator(\n...             data=DataGenerator([1, 2, 3]),\n...             path_uri=Path(tmpdir).joinpath(\"uri\"),\n...             path_shard=Path(tmpdir).joinpath(\"data\"),\n...         ),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         num_shards=5,\n...     )\n...     generator\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nShardTupleGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (num_shards): 5\n  (shard): JsonShardGenerator(\n      (path_uri): PosixPath('/.../uri')\n      (path_shard): PosixPath('/.../data')\n      (data): DataGenerator(copy=False)\n    )\n)\nShardTuple(\n  (uri): file:///.../uri/shard1\n  (shards):\n    (0): JsonShard(uri=file:///.../uri/000000001)\n    (1): JsonShard(uri=file:///.../uri/000000002)\n    (2): JsonShard(uri=file:///.../uri/000000003)\n    (3): JsonShard(uri=file:///.../uri/000000004)\n    (4): JsonShard(uri=file:///.../uri/000000005)\n)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.TorchSafetensorsShardGenerator","title":"iden.shard.generator.TorchSafetensorsShardGenerator","text":"<p>               Bases: <code>BaseFileShardGenerator[dict[str, Tensor]]</code></p> <p>Implement a safetensors shard generator.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BaseDataGenerator[dict[str, Tensor]] | dict[Any, Any]</code> <p>The data to save in the shard.</p> required <code>path_uri</code> <code>Path</code> <p>The path where to save the URI file.</p> required <code>path_shard</code> <code>Path</code> <p>The path where to save the shard data.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import TorchSafetensorsShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = TorchSafetensorsShardGenerator(\n...         data=DataGenerator({\"key1\": torch.ones(2, 3), \"key2\": torch.arange(5)}),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nTorchSafetensorsShardGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (path_shard): PosixPath('/.../data')\n  (data): DataGenerator(copy=False)\n)\nTorchSafetensorsShard(uri=file:///.../uri/shard1)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.TorchShardGenerator","title":"iden.shard.generator.TorchShardGenerator","text":"<p>               Bases: <code>BaseFileShardGenerator[T]</code></p> <p>Implement a torch shard generator.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BaseDataGenerator[T] | dict[Any, Any]</code> <p>The data to save in the shard.</p> required <code>path_uri</code> <code>Path</code> <p>The path where to save the URI file.</p> required <code>path_shard</code> <code>Path</code> <p>The path where to save the shard data.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import TorchShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = TorchShardGenerator(\n...         data=DataGenerator([1, 2, 3]),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nTorchShardGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (path_shard): PosixPath('/.../data')\n  (data): DataGenerator(copy=False)\n)\nTorchShard(uri=file:///.../uri/shard1)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.YamlShardGenerator","title":"iden.shard.generator.YamlShardGenerator","text":"<p>               Bases: <code>BaseFileShardGenerator[T]</code></p> <p>Implement a YAML shard generator.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BaseDataGenerator[T] | dict[Any, Any]</code> <p>The data to save in the shard.</p> required <code>path_uri</code> <code>Path</code> <p>The path where to save the URI file.</p> required <code>path_shard</code> <code>Path</code> <p>The path where to save the shard data.</p> required Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.data.generator import DataGenerator\n&gt;&gt;&gt; from iden.shard.generator import YamlShardGenerator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = YamlShardGenerator(\n...         data=DataGenerator([1, 2, 3]),\n...         path_uri=Path(tmpdir).joinpath(\"uri\"),\n...         path_shard=Path(tmpdir).joinpath(\"data\"),\n...     )\n...     generator\n...     shard = generator.generate(\"shard1\")\n...     shard\n...\nYamlShardGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (path_shard): PosixPath('/.../data')\n  (data): DataGenerator(copy=False)\n)\nYamlShard(uri=file:///.../uri/shard1)\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.is_shard_generator_config","title":"iden.shard.generator.is_shard_generator_config","text":"<pre><code>is_shard_generator_config(config: dict[Any, Any]) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseShardGenerator</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[Any, Any]</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseShardGenerator</code> object.</p> Example <pre><code>&gt;&gt;&gt; from iden.shard.generator import is_shard_generator_config\n&gt;&gt;&gt; is_shard_generator_config({\"_target_\": \"iden.shard.generator.JsonShardGenerator\"})\nTrue\n</code></pre>"},{"location":"refs/shard/#iden.shard.generator.setup_shard_generator","title":"iden.shard.generator.setup_shard_generator","text":"<pre><code>setup_shard_generator(\n    shard_generator: (\n        BaseShardGenerator[T] | dict[Any, Any]\n    ),\n) -&gt; BaseShardGenerator[T]\n</code></pre> <p>Set up a shard generator.</p> <p>The shard generator is instantiated from its configuration by using the <code>BaseShardGenerator</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>shard_generator</code> <code>BaseShardGenerator[T] | dict[Any, Any]</code> <p>The shard generator or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseShardGenerator[T]</code> <p>The instantiated shard generator.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard.generator import setup_shard_generator\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     generator = setup_shard_generator(\n...         {\n...             \"_target_\": \"iden.shard.generator.JsonShardGenerator\",\n...             \"data\": [1, 2, 3],\n...             \"path_uri\": Path(tmpdir).joinpath(\"uri\"),\n...             \"path_shard\": Path(tmpdir).joinpath(\"data\"),\n...         }\n...     )\n...     generator\n...\nJsonShardGenerator(\n  (path_uri): PosixPath('/.../uri')\n  (path_shard): PosixPath('/.../data')\n  (data): [1, 2, 3]\n)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader","title":"iden.shard.loader","text":"<p>Contain shard loader implementations.</p>"},{"location":"refs/shard/#iden.shard.loader.BaseShardLoader","title":"iden.shard.loader.BaseShardLoader","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a shard loader.</p> <p>A shard loader object allows to load a <code>BaseShard</code> object from its Uniform Resource Identifier (URI).</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; from iden.shard.loader import JsonShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_json_shard([1, 2, 3], uri=uri)\n...     loader = JsonShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nJsonShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.BaseShardLoader.equal","title":"iden.shard.loader.BaseShardLoader.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare with.</p> required <code>equal_nan</code> <code>bool</code> <p>If <code>True</code>, then two <code>NaN</code>s will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two objects are equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.shard.loader import JsonShardLoader, PickleShardLoader\n&gt;&gt;&gt; JsonShardLoader().equal(JsonShardLoader())\nTrue\n&gt;&gt;&gt; JsonShardLoader().equal(PickleShardLoader())\nFalse\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.BaseShardLoader.load","title":"iden.shard.loader.BaseShardLoader.load  <code>abstractmethod</code>","text":"<pre><code>load(uri: str) -&gt; BaseShard[T]\n</code></pre> <p>Load a shard from its Uniform Resource Identifier (URI).</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The URI of the shard to load.</p> required <p>Returns:</p> Type Description <code>BaseShard[T]</code> <p>The loaded shard.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; from iden.shard.loader import JsonShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_json_shard([1, 2, 3], uri=uri)\n...     loader = JsonShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nJsonShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.CloudpickleShardLoader","title":"iden.shard.loader.CloudpickleShardLoader","text":"<p>               Bases: <code>BaseShardLoader[T]</code></p> <p>Implement a cloudpickle shard loader.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_cloudpickle_shard\n&gt;&gt;&gt; from iden.shard.loader import CloudpickleShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_cloudpickle_shard([1, 2, 3], uri=uri)\n...     loader = CloudpickleShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nCloudpickleShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.FileShardLoader","title":"iden.shard.loader.FileShardLoader","text":"<p>               Bases: <code>BaseShardLoader[T]</code></p> <p>Implement a file-based shard loader.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; from iden.shard.loader import FileShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_json_shard([1, 2, 3], uri=uri)\n...     loader = FileShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nJsonShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.JoblibShardLoader","title":"iden.shard.loader.JoblibShardLoader","text":"<p>               Bases: <code>BaseShardLoader[T]</code></p> <p>Implement a joblib shard loader for loading shards from joblib files.</p> <p>This loader reads shard configuration from a URI and instantiates a joblib shard with the specified data file path.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_joblib_shard\n&gt;&gt;&gt; from iden.shard.loader import JoblibShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_joblib_shard([1, 2, 3], uri=uri)\n...     loader = JoblibShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nJoblibShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.JsonShardLoader","title":"iden.shard.loader.JsonShardLoader","text":"<p>               Bases: <code>BaseShardLoader[T]</code></p> <p>Implement a JSON shard loader for loading shards from JSON files.</p> <p>This loader reads shard configuration from a URI and instantiates a JSON shard with the specified data file path.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; from iden.shard.loader import JsonShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_json_shard([1, 2, 3], uri=uri)\n...     loader = JsonShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nJsonShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.NumpySafetensorsShardLoader","title":"iden.shard.loader.NumpySafetensorsShardLoader","text":"<p>               Bases: <code>BaseShardLoader[dict[str, ndarray]]</code></p> <p>Implement a safetensors shard loader for <code>numpy.ndarray</code>s.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>safetensors</code> or <code>numpy</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_numpy_safetensors_shard\n&gt;&gt;&gt; from iden.shard.loader import NumpySafetensorsShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_numpy_safetensors_shard(\n...         {\"key1\": np.ones((2, 3)), \"key2\": np.arange(5)}, uri=uri\n...     )\n...     loader = NumpySafetensorsShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nNumpySafetensorsShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.PickleShardLoader","title":"iden.shard.loader.PickleShardLoader","text":"<p>               Bases: <code>BaseShardLoader[T]</code></p> <p>Implement a pickle shard loader for loading shards from pickle files.</p> <p>This loader reads shard configuration from a URI and instantiates a pickle shard with the specified data file path.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_pickle_shard\n&gt;&gt;&gt; from iden.shard.loader import PickleShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_pickle_shard([1, 2, 3], uri=uri)\n...     loader = PickleShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nPickleShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.ShardDictLoader","title":"iden.shard.loader.ShardDictLoader","text":"<p>               Bases: <code>BaseShardLoader[dict[str, BaseShard[T]]]</code></p> <p>Implement a shard dictionary loader for loading dictionary- structured shards.</p> <p>This loader reads shard configuration from a URI and instantiates a ShardDict containing multiple named shards.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict\n&gt;&gt;&gt; from iden.shard.loader import ShardDictLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"uri\").as_uri()\n...     shards = {\n...         \"train\": create_json_shard(\n...             [1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()\n...         ),\n...         \"val\": create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     }\n...     create_shard_dict(shards, uri=uri)\n...     loader = ShardDictLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nShardDict(\n  (uri): file:///.../uri\n  (shards):\n    (train): JsonShard(uri=file:///.../shard/uri1)\n    (val): JsonShard(uri=file:///.../shard/uri2)\n)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.ShardTupleLoader","title":"iden.shard.loader.ShardTupleLoader","text":"<p>               Bases: <code>BaseShardLoader[tuple[BaseShard[T], ...]]</code></p> <p>Implement a shard tuple loader for loading sequence-structured shards.</p> <p>This loader reads shard configuration from a URI and instantiates a ShardTuple containing an ordered sequence of shards.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_tuple\n&gt;&gt;&gt; from iden.shard.loader import ShardTupleLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"uri\").as_uri()\n...     shards = [\n...         create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"shard/uri1\").as_uri()),\n...         create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shard/uri2\").as_uri()\n...         ),\n...     ]\n...     create_shard_tuple(shards, uri=uri)\n...     loader = ShardTupleLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nShardTuple(\n  (uri): file:///.../uri\n  (shards):\n    (0): JsonShard(uri=file:///.../shard/uri1)\n    (1): JsonShard(uri=file:///.../shard/uri2)\n)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.TorchSafetensorsShardLoader","title":"iden.shard.loader.TorchSafetensorsShardLoader","text":"<p>               Bases: <code>BaseShardLoader[dict[str, Tensor]]</code></p> <p>Implement a safetensors shard loader for <code>torch.Tensor</code>s.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>safetensors</code> or <code>torch</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_torch_safetensors_shard\n&gt;&gt;&gt; from iden.shard.loader import TorchSafetensorsShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_torch_safetensors_shard(\n...         {\"key1\": torch.ones(2, 3), \"key2\": torch.arange(5)}, uri=uri\n...     )\n...     loader = TorchSafetensorsShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nTorchSafetensorsShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.TorchShardLoader","title":"iden.shard.loader.TorchShardLoader","text":"<p>               Bases: <code>BaseShardLoader[T]</code></p> <p>Implement a PyTorch shard loader for loading shards from PyTorch files.</p> <p>This loader reads shard configuration from a URI and instantiates a PyTorch shard with the specified data file path.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>torch</code> is not installed.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_torch_shard\n&gt;&gt;&gt; from iden.shard.loader import TorchShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_torch_shard([1, 2, 3], uri=uri)\n...     loader = TorchShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nTorchShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.YamlShardLoader","title":"iden.shard.loader.YamlShardLoader","text":"<p>               Bases: <code>BaseShardLoader[T]</code></p> <p>Implement a YAML shard loader for loading shards from YAML files.</p> <p>This loader reads shard configuration from a URI and instantiates a YAML shard with the specified data file path.</p> Example <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_yaml_shard\n&gt;&gt;&gt; from iden.shard.loader import YamlShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     create_yaml_shard([1, 2, 3], uri=uri)\n...     loader = YamlShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nYamlShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.is_shard_loader_config","title":"iden.shard.loader.is_shard_loader_config","text":"<pre><code>is_shard_loader_config(config: dict[Any, Any]) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseShardLoader</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[Any, Any]</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseShardLoader</code> object.</p> Example <pre><code>&gt;&gt;&gt; from iden.shard.loader import is_shard_loader_config\n&gt;&gt;&gt; is_shard_loader_config({\"_target_\": \"iden.shard.loader.JsonShardLoader\"})\nTrue\n</code></pre>"},{"location":"refs/shard/#iden.shard.loader.setup_shard_loader","title":"iden.shard.loader.setup_shard_loader","text":"<pre><code>setup_shard_loader(\n    shard_loader: BaseShardLoader[T] | dict[Any, Any],\n) -&gt; BaseShardLoader[T]\n</code></pre> <p>Set up a shard loader.</p> <p>The shard loader is instantiated from its configuration by using the <code>BaseShardLoader</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>shard_loader</code> <code>BaseShardLoader[T] | dict[Any, Any]</code> <p>The shard loader or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseShardLoader[T]</code> <p>The instantiated shard loader.</p> Example <pre><code>&gt;&gt;&gt; from iden.shard.loader import setup_shard_loader\n&gt;&gt;&gt; shard_loader = setup_shard_loader({\"_target_\": \"iden.shard.loader.JsonShardLoader\"})\n&gt;&gt;&gt; shard_loader\nJsonShardLoader()\n</code></pre>"},{"location":"refs/testing/","title":"iden.testing","text":""},{"location":"refs/testing/#iden.testing","title":"iden.testing","text":"<p>Contain some utility functions for testing.</p>"},{"location":"refs/utils/","title":"iden.utils","text":""},{"location":"refs/utils/#iden.utils","title":"iden.utils","text":"<p>Contain the utility functions.</p>"},{"location":"refs/utils/#iden.utils.comparator","title":"iden.utils.comparator","text":"<p>Contain a generic comparator for iden objects to be used with <code>coola.objects_are_equal</code>.</p>"},{"location":"refs/utils/#iden.utils.comparator.ObjectEqualityComparator","title":"iden.utils.comparator.ObjectEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[T]</code></p> <p>Implement an equality comparator for <code>BaseLoader</code> objects.</p>"},{"location":"refs/utils/#iden.utils.fallback","title":"iden.utils.fallback","text":"<p>Contain fallback implementations used when optional dependencies are missing, ensuring the package remains importable and can operate with limited functionality.</p>"},{"location":"refs/utils/#iden.utils.format","title":"iden.utils.format","text":"<p>Contain utility functions to compute formatted strings.</p>"},{"location":"refs/utils/#iden.utils.format.human_time","title":"iden.utils.format.human_time","text":"<pre><code>human_time(seconds: float) -&gt; str\n</code></pre> <p>Return a number of seconds in an easier format to read <code>hh:mm:ss</code>.</p> <p>If the number of seconds is bigger than 1 day, this representation also encodes the number of days.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>The number of seconds.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The number of seconds in a string format (<code>hh:mm:ss</code>).</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.format import human_time\n&gt;&gt;&gt; human_time(1.2)\n'0:00:01.200000'\n&gt;&gt;&gt; human_time(61.2)\n'0:01:01.200000'\n&gt;&gt;&gt; human_time(3661.2)\n'1:01:01.200000'\n</code></pre>"},{"location":"refs/utils/#iden.utils.format.str_kwargs","title":"iden.utils.format.str_kwargs","text":"<pre><code>str_kwargs(mapping: Mapping[Any, Any]) -&gt; str\n</code></pre> <p>Return a string of the input mapping.</p> <p>This function is designed to be used in <code>__repr__</code> and <code>__str__</code> methods.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[Any, Any]</code> <p>The mapping of key-value pairs to format as a string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.format import str_kwargs\n&gt;&gt;&gt; str_kwargs({\"key1\": 1})\n', key1=1'\n&gt;&gt;&gt; str_kwargs({\"key1\": 1, \"key2\": 2})\n', key1=1, key2=2'\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports","title":"iden.utils.imports","text":"<p>Implement some utility functions to manage optional dependencies.</p>"},{"location":"refs/utils/#iden.utils.imports.check_cloudpickle","title":"iden.utils.imports.check_cloudpickle","text":"<pre><code>check_cloudpickle() -&gt; None\n</code></pre> <p>Check if the <code>cloudpickle</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>cloudpickle</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import check_cloudpickle\n&gt;&gt;&gt; check_cloudpickle()\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports.check_joblib","title":"iden.utils.imports.check_joblib","text":"<pre><code>check_joblib() -&gt; None\n</code></pre> <p>Check if the <code>joblib</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>joblib</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import check_joblib\n&gt;&gt;&gt; check_joblib()\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports.check_safetensors","title":"iden.utils.imports.check_safetensors","text":"<pre><code>check_safetensors() -&gt; None\n</code></pre> <p>Check if the <code>safetensors</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>safetensors</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import check_safetensors\n&gt;&gt;&gt; check_safetensors()\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports.check_yaml","title":"iden.utils.imports.check_yaml","text":"<pre><code>check_yaml() -&gt; None\n</code></pre> <p>Check if the <code>yaml</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>yaml</code> package is not installed.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import check_yaml\n&gt;&gt;&gt; check_yaml()\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports.cloudpickle_available","title":"iden.utils.imports.cloudpickle_available","text":"<pre><code>cloudpickle_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>cloudpickle</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>cloudpickle</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import cloudpickle_available\n&gt;&gt;&gt; @cloudpickle_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports.is_cloudpickle_available","title":"iden.utils.imports.is_cloudpickle_available","text":"<pre><code>is_cloudpickle_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>cloudpickle</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>cloudpickle</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import is_cloudpickle_available\n&gt;&gt;&gt; is_cloudpickle_available()\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports.is_joblib_available","title":"iden.utils.imports.is_joblib_available","text":"<pre><code>is_joblib_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>joblib</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>joblib</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import is_joblib_available\n&gt;&gt;&gt; is_joblib_available()\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports.is_safetensors_available","title":"iden.utils.imports.is_safetensors_available","text":"<pre><code>is_safetensors_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>safetensors</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>safetensors</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import is_safetensors_available\n&gt;&gt;&gt; is_safetensors_available()\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports.is_yaml_available","title":"iden.utils.imports.is_yaml_available","text":"<pre><code>is_yaml_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>yaml</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>yaml</code> is available otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import is_yaml_available\n&gt;&gt;&gt; is_yaml_available()\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports.joblib_available","title":"iden.utils.imports.joblib_available","text":"<pre><code>joblib_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>joblib</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>joblib</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import joblib_available\n&gt;&gt;&gt; @joblib_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports.raise_error_cloudpickle_missing","title":"iden.utils.imports.raise_error_cloudpickle_missing","text":"<pre><code>raise_error_cloudpickle_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>cloudpickle</code> package is missing.</p>"},{"location":"refs/utils/#iden.utils.imports.raise_error_joblib_missing","title":"iden.utils.imports.raise_error_joblib_missing","text":"<pre><code>raise_error_joblib_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>joblib</code> package is missing.</p>"},{"location":"refs/utils/#iden.utils.imports.raise_error_safetensors_missing","title":"iden.utils.imports.raise_error_safetensors_missing","text":"<pre><code>raise_error_safetensors_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>safetensors</code> package is missing.</p>"},{"location":"refs/utils/#iden.utils.imports.raise_error_yaml_missing","title":"iden.utils.imports.raise_error_yaml_missing","text":"<pre><code>raise_error_yaml_missing() -&gt; NoReturn\n</code></pre> <p>Raise a RuntimeError to indicate the <code>yaml</code> package is missing.</p>"},{"location":"refs/utils/#iden.utils.imports.safetensors_available","title":"iden.utils.imports.safetensors_available","text":"<pre><code>safetensors_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>safetensors</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>safetensors</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import safetensors_available\n&gt;&gt;&gt; @safetensors_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#iden.utils.imports.yaml_available","title":"iden.utils.imports.yaml_available","text":"<pre><code>yaml_available(\n    fn: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>yaml</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>yaml</code> package is installed, otherwise <code>None</code>.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.imports import yaml_available\n&gt;&gt;&gt; @yaml_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#iden.utils.time","title":"iden.utils.time","text":"<p>Contain utility functions to measure time.</p>"},{"location":"refs/utils/#iden.utils.time.sync_perf_counter","title":"iden.utils.time.sync_perf_counter","text":"<pre><code>sync_perf_counter() -&gt; float\n</code></pre> <p>Extension of <code>time.perf_counter</code> that waits for all kernels in all streams on a CUDA device to complete.</p> <p>Returns:</p> Type Description <code>float</code> <p>Same as <code>time.perf_counter()</code>. See https://docs.python.org/3/library/time.html#time.perf_counter for more information.</p> Example <pre><code>&gt;&gt;&gt; from iden.utils.time import sync_perf_counter\n&gt;&gt;&gt; tic = sync_perf_counter()\n&gt;&gt;&gt; x = [1, 2, 3]\n&gt;&gt;&gt; toc = sync_perf_counter()\n&gt;&gt;&gt; toc - tic\n</code></pre>"},{"location":"refs/utils/#iden.utils.time.timeblock","title":"iden.utils.time.timeblock","text":"<pre><code>timeblock(\n    message: str = \"Total time: {time}\",\n) -&gt; Generator[None, None, None]\n</code></pre> <p>Implement a context manager to measure the execution time of a block of code.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message displayed when the time is logged.</p> <code>'Total time: {time}'</code> Example <pre><code>&gt;&gt;&gt; from iden.utils.time import timeblock\n&gt;&gt;&gt; with timeblock():\n...     x = [1, 2, 3]\n...\n&gt;&gt;&gt; with timeblock(\"Training: {time}\"):\n...     y = [1, 2, 3]\n...\n</code></pre>"},{"location":"uguide/dataset/","title":"Dataset","text":""},{"location":"uguide/dataset/#overview","title":"Overview","text":"<p>The dataset is an abstraction to manage collections of shards organized into splits (e.g., train, validation, test) and assets (e.g., metadata, statistics). <code>iden</code> provides a simple and flexible way to organize and access your machine learning datasets without loading all data into memory at once.</p>"},{"location":"uguide/dataset/#creating-a-dataset","title":"Creating a dataset","text":"<p>A dataset can be created using the <code>create_vanilla_dataset</code> function or directly using the <code>VanillaDataset</code> class.</p>"},{"location":"uguide/dataset/#using-create_vanilla_dataset","title":"Using create_vanilla_dataset","text":"<p>The <code>create_vanilla_dataset</code> function is the recommended way to create datasets:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import create_vanilla_dataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     # Create shards using create_shard_tuple\n...     train_shards = create_shard_tuple(\n...         [\n...             create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"train1\").as_uri()),\n...             create_json_shard([4, 5, 6], uri=Path(tmpdir).joinpath(\"train2\").as_uri()),\n...         ],\n...         uri=Path(tmpdir).joinpath(\"train_tuple\").as_uri(),\n...     )\n...     # Create shards dictionary\n...     shards = create_shard_dict(\n...         shards={\"train\": train_shards},\n...         uri=Path(tmpdir).joinpath(\"shards\").as_uri(),\n...     )\n...     # Create assets (can be empty)\n...     assets = create_shard_dict(\n...         shards={},\n...         uri=Path(tmpdir).joinpath(\"assets\").as_uri(),\n...     )\n...     # Create dataset\n...     dataset = create_vanilla_dataset(\n...         shards=shards,\n...         assets=assets,\n...         uri=Path(tmpdir).joinpath(\"dataset\").as_uri(),\n...     )\n...     dataset\n...\nVanillaDataset(\n  (uri): file:///.../dataset\n  (shards): ShardDict(...)\n  (assets): ShardDict(...)\n)\n</code></pre>"},{"location":"uguide/dataset/#accessing-shards","title":"Accessing shards","text":"<p>You can access shards by split name using the <code>get_shards</code> method, which returns a tuple of shards:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import create_vanilla_dataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     train_shards = create_shard_tuple(\n...         [\n...             create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"train1\").as_uri()),\n...             create_json_shard([4, 5, 6], uri=Path(tmpdir).joinpath(\"train2\").as_uri()),\n...         ],\n...         uri=Path(tmpdir).joinpath(\"train_tuple\").as_uri(),\n...     )\n...     val_shards = create_shard_tuple(\n...         [create_json_shard([7, 8, 9], uri=Path(tmpdir).joinpath(\"val1\").as_uri())],\n...         uri=Path(tmpdir).joinpath(\"val_tuple\").as_uri(),\n...     )\n...     shards = create_shard_dict(\n...         shards={\"train\": train_shards, \"val\": val_shards},\n...         uri=Path(tmpdir).joinpath(\"shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(\n...         shards={},\n...         uri=Path(tmpdir).joinpath(\"assets\").as_uri(),\n...     )\n...     dataset = create_vanilla_dataset(\n...         shards=shards,\n...         assets=assets,\n...         uri=Path(tmpdir).joinpath(\"dataset\").as_uri(),\n...     )\n...     # Get training shards\n...     train_data = dataset.get_shards(\"train\")\n...     # Access individual shards by index\n...     first_shard = train_data[0]\n...     first_shard.get_data()\n...\n[1, 2, 3]\n</code></pre>"},{"location":"uguide/dataset/#working-with-assets","title":"Working with assets","text":"<p>Assets allow you to store metadata, statistics, or other auxiliary information alongside your dataset:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import create_vanilla_dataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     # Create minimal shards\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"data\").as_uri()\n...                     )\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"train_tuple\").as_uri(),\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"shards\").as_uri(),\n...     )\n...     # Create assets\n...     assets = create_shard_dict(\n...         shards={\n...             \"metadata\": create_json_shard(\n...                 {\"version\": \"1.0\", \"num_samples\": 1000},\n...                 uri=Path(tmpdir).joinpath(\"metadata\").as_uri(),\n...             ),\n...             \"stats\": create_json_shard(\n...                 {\"mean\": 0.5, \"std\": 0.25},\n...                 uri=Path(tmpdir).joinpath(\"stats\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"assets\").as_uri(),\n...     )\n...     dataset = create_vanilla_dataset(\n...         shards=shards,\n...         assets=assets,\n...         uri=Path(tmpdir).joinpath(\"dataset\").as_uri(),\n...     )\n...     # Access assets\n...     metadata = dataset.get_asset(\"metadata\")\n...     metadata.get_data()\n...\n{'version': '1.0', 'num_samples': 1000}\n</code></pre>"},{"location":"uguide/dataset/#available-splits","title":"Available splits","text":"<p>You can check which splits are available in your dataset using <code>get_splits()</code>:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import create_vanilla_dataset\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"train\").as_uri()\n...                     )\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"train_tuple\").as_uri(),\n...             ),\n...             \"val\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [4, 5, 6], uri=Path(tmpdir).joinpath(\"val\").as_uri()\n...                     )\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"val_tuple\").as_uri(),\n...             ),\n...             \"test\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [7, 8, 9], uri=Path(tmpdir).joinpath(\"test\").as_uri()\n...                     )\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"test_tuple\").as_uri(),\n...             ),\n...         },\n...         uri=Path(tmpdir).joinpath(\"shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(shards={}, uri=Path(tmpdir).joinpath(\"assets\").as_uri())\n...     dataset = create_vanilla_dataset(\n...         shards=shards,\n...         assets=assets,\n...         uri=Path(tmpdir).joinpath(\"dataset\").as_uri(),\n...     )\n...     sorted(dataset.get_splits())\n...\n['test', 'train', 'val']\n</code></pre>"},{"location":"uguide/dataset/#saving-and-loading-datasets","title":"Saving and loading datasets","text":"<p>Datasets are automatically saved when created with <code>create_vanilla_dataset</code> and can be loaded using <code>load_from_uri</code>:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.dataset import create_vanilla_dataset, load_from_uri\n&gt;&gt;&gt; from iden.shard import create_json_shard, create_shard_dict, create_shard_tuple\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     # Create and save dataset\n...     shards = create_shard_dict(\n...         shards={\n...             \"train\": create_shard_tuple(\n...                 [\n...                     create_json_shard(\n...                         [1, 2, 3], uri=Path(tmpdir).joinpath(\"train\").as_uri()\n...                     )\n...                 ],\n...                 uri=Path(tmpdir).joinpath(\"train_tuple\").as_uri(),\n...             )\n...         },\n...         uri=Path(tmpdir).joinpath(\"shards\").as_uri(),\n...     )\n...     assets = create_shard_dict(shards={}, uri=Path(tmpdir).joinpath(\"assets\").as_uri())\n...     dataset = create_vanilla_dataset(\n...         shards=shards,\n...         assets=assets,\n...         uri=Path(tmpdir).joinpath(\"dataset\").as_uri(),\n...     )\n...     # Load dataset from URI\n...     loaded_dataset = load_from_uri(Path(tmpdir).joinpath(\"dataset\").as_uri())\n...     loaded_dataset.get_uri()\n...\n'file:///.../dataset'\n</code></pre>"},{"location":"uguide/shard/","title":"Shard","text":""},{"location":"uguide/shard/#overview","title":"Overview","text":"<p>The shard is an abstraction to represent a unit of data. It provides an abstraction to get the data without knowing how the data are stored. Each shard must have a unique Uniform Resource Identifier (URI), which is used to identify each shard, so it is possible to instantiate a shard from its URI. The <code>get_uri</code> method can be used to get the URI of shard:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"my_uri\").as_uri())\n...     uri = shard.get_uri()\n...     uri\n...\n'file:///.../my_uri'\n</code></pre> <p>To be scalable, a shard does not contain the data, but it contains the logic to get the data. It allows to create and manage a large number of shards independently of the total size of the data. The <code>get_data</code> method is used to get the data from the shard:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"my_uri\").as_uri())\n...     data = shard.get_data()\n...     data\n...\n[1, 2, 3]\n</code></pre> <p>If the data from a shard are often used, it is possible to cache them by specifying <code>cache=True</code>:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"my_uri\").as_uri())\n...     data = shard.get_data(cache=True)\n...     data\n...\n[1, 2, 3]\n</code></pre> <p>Most of the shards can cache the data in-memory. It is possible to clear the cache by calling the <code>clear</code> method.</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"my_uri\").as_uri())\n...     data = shard.get_data(cache=True)\n...     data\n...     data.append(4)  # in-place modification\n...     data = shard.get_data()\n...     data\n...     shard.clear()\n...     data = shard.get_data()\n...     data\n...\n[1, 2, 3]\n[1, 2, 3, 4]\n[1, 2, 3]\n</code></pre> <p>It is important to clear the <code>cache</code> if the shard is not used because it can lead to OOM issues if the data of too may shards are cached in-memory at the same time. It is possible to call the <code>is_cached</code> method to know if the data in the data are cached or not.</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shard = create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"my_uri\").as_uri())\n...     shard.is_cached()\n...     data = shard.get_data(cache=True)\n...     shard.is_cached()\n...     shard.clear()\n...     shard.is_cached()\n...\nFalse\nTrue\nFalse\n</code></pre> <p>Finally, there is the <code>equal</code> method to check if two shards are equal or not:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import JsonShard, create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri1 = Path(tmpdir).joinpath(\"my_uri1\").as_uri()\n...     uri2 = Path(tmpdir).joinpath(\"my_uri2\").as_uri()\n...     shard1 = create_json_shard([1, 2, 3], uri=uri1)\n...     shard2 = create_json_shard([4, 5, 6], uri=uri2)\n...     shard3 = JsonShard.from_uri(uri=uri1)\n...     shard1.equal(shard2)\n...     shard1.equal(shard3)\n...\nFalse\nTrue\n</code></pre>"},{"location":"uguide/shard/#built-in-shards","title":"Built-in shards","text":"<p><code>iden</code> has some built-in shard implementations that can be used out of the box. It is possible to extend <code>iden</code> to support more shard implementation. This page explains how to add a new shard implementation.</p> <p>Each shard implementation is different and has different properties. The best shard should be chosen based on the requirements. It is not a one size fits all. For example, the <code>PickleShard</code> implementation supports a lot of types of data whereas the <code>TorchSafetensorsShard</code> implementation only supports dictionary of <code>torch.Tensor</code>s. The following table shows a summary of supported data for some of the built-in shards.</p> shard supported data <code>FileShard</code> depend on the file format <code>JsonShard</code> any data compatible with JSON format <code>PickleShard</code> any serializable data <code>TorchSafetensorsShard</code> a dictionary of <code>torch.Tensor</code>s <code>TorchShard</code> any serializable data <code>YamlShard</code> any data compatible with YAML format <p>File-based shards. <code>iden</code> has some shard implementations to load data from files. <code>iden</code> relies on existing packages to save and load data in s shard. Most of these packages are optional and should be installed if necessary. The following table shows some of the supported file format, the package used to save and load data, and their associated shard implementations.</p> shard file format package <code>JsonShard</code> JSON file <code>json</code> <code>PickleShard</code> pickle file <code>yaml</code> <code>TorchSafetensorsShard</code> safetensors file <code>safetensors</code> <code>TorchShard</code> pytorch file <code>torch</code> <code>YamlShard</code> YAML file <code>yaml</code> <p><code>FileShard</code> is generic file-based shard that supports most of the file formats.</p> <p>Special shards. <code>iden</code> has some special shards that allows to combine multiple shards. <code>ShardTuple</code> is the shard implementation to manage a tuple of shards.</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import ShardTuple, create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = [\n...         create_json_shard([1, 2, 3], uri=Path(tmpdir).joinpath(\"shards/uri1\").as_uri()),\n...         create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shards/uri2\").as_uri()\n...         ),\n...     ]\n...     sl = ShardTuple(uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards)\n...     sl\n...\nShardTuple(\n  (uri): file:///.../uri\n  (shards):\n    (0): JsonShard(uri=file:///.../shards/uri1)\n    (1): JsonShard(uri=file:///.../shards/uri2)\n)\n</code></pre> <p><code>ShardDict</code> is the shard implementation to manage a dictionary of shards.</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import ShardDict, create_json_shard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     shards = {\n...         \"train\": create_json_shard(\n...             [1, 2, 3], uri=Path(tmpdir).joinpath(\"shards/uri1\").as_uri()\n...         ),\n...         \"val\": create_json_shard(\n...             [4, 5, 6, 7], uri=Path(tmpdir).joinpath(\"shards/uri2\").as_uri()\n...         ),\n...     }\n...     sd = ShardDict(uri=Path(tmpdir).joinpath(\"uri\").as_uri(), shards=shards)\n...     sd\n...\nShardDict(\n  (uri): file:///.../uri\n  (shards):\n    (train): JsonShard(uri=file:///.../shards/uri1)\n    (val): JsonShard(uri=file:///.../shards/uri2)\n)\n</code></pre>"},{"location":"uguide/shard/#instantiating-a-shard-from-its-uri","title":"Instantiating a shard from its URI","text":"<p><code>iden</code> has a functionality to instantiate a shard from its Uniform Resource Identifier (URI). A shard can be represented by its URI, which can help to make the data management more scalable. It is easier to manage the URIs than all the data. The <code>load_from_uri</code> function can be used to instantiate a shard from its URI.</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard, load_from_uri\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     _ = create_json_shard([1, 2, 3], uri=uri)\n...     shard = load_from_uri(uri)\n...     shard\n...\nJsonShard(uri=file:///.../my_uri)\n</code></pre> <p>Under the hood, the <code>load_from_uri</code> function relies on a shard loader object to instantiate a shard object. A shard loader contains the logic to instantiate a shard object from its URI. For instance in the previous example, the <code>JsonShardLoader</code> class is used to instantiate the <code>JsonShard</code> object. <code>load_from_uri</code> is a universal function to load any shards, but it is also possible to use specific data loaders. For instance, the following example is equivalent to the previous example:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import create_json_shard\n&gt;&gt;&gt; from iden.shard.loader import JsonShardLoader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     uri = Path(tmpdir).joinpath(\"my_uri\").as_uri()\n...     _ = create_json_shard([1, 2, 3], uri=uri)\n...     loader = JsonShardLoader()\n...     shard = loader.load(uri)\n...     shard\n...\nJsonShard(uri=file:///.../my_uri)\n</code></pre>"},{"location":"uguide/shard/#uniform-resource-identifier-uri","title":"Uniform Resource Identifier (URI)","text":"<p>The URI file contains enough information to instantiate the shard object, and it is encoded as a JSON file. All URI files should contain a dictionary, with at least one key which indicates which the shard loader to use to instantiate the shard. The following example shows the generate configuration for a <code>JsonShard</code> object:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from iden.shard import JsonShard\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.json\")\n...     config = JsonShard.generate_uri_config(path)\n...     config\n...\n{'kwargs': {'path': '/.../data.json'},\n 'loader': {'_target_': 'iden.shard.loader.JsonShardLoader'}}\n</code></pre> <p>The <code>'kwargs'</code> key is specific to <code>JsonShard</code> and indicates where to find the JSON file associated to the shard.</p>"}]}